<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Basic hardening headers (still compatible with inline CSS/JS in this single-file build) -->
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               base-uri 'self';
               object-src 'none';
               frame-ancestors 'self';
               img-src 'self' blob: data:;
               style-src 'self' 'unsafe-inline';
               script-src 'self' 'unsafe-inline';
               connect-src 'self';
               form-action 'self'">
<meta name="referrer" content="no-referrer" />
<meta http-equiv="X-Content-Type-Options" content="nosniff" />

<title>Centaur Web</title>

<style>
/* =====================
   PREMIUM THEME SYSTEM
   - Shared elevation/shadows
   - Focus rings
   - Theme toggle (Auto/Dark/Light)
   - Contrast toggle (Standard/Clinic)
   - Better typography + spacing
===================== */
:root{
  /* Clinic-optimized light defaults (reduced glare, high legibility) */
  --bg:#F4F6F9;
  --bg2:#EDF1F6;
  --panel:#F7F9FB;
  --panel2:#FFFFFF;
  --border:#D0D7E2;
  --text:#0F172A;
  --muted:#475569;
  --accent:#1D4ED8;
  --danger:#DC2626;
  --ok:#059669;
  --warn:#B45309;

  --r:14px;
  --pad:14px;
  --gap:14px;

  /* Elevation + effects */
  --shadow-xs: 0 1px 1px rgba(0,0,0,.05);
  --shadow-sm: 0 1px 2px rgba(0,0,0,.06);
  --shadow-md: 0 10px 24px rgba(0,0,0,.08);
  --shadow-lg: 0 18px 42px rgba(0,0,0,.12);
  --focus: 0 0 0 3px rgba(37,99,235,.28);

  /* Layout tuning */
  --rowH: 620px;          /* fixed height for the 3-column row */
  --colLeft: 360px;       /* Transcript == Coach; Query gets the rest */
  --topFrac: 0.333;       /* Transcript top 1/3 */
  --botFrac: 0.667;       /* Snapshot bottom 2/3 */

  /* Motion */
  --ease: cubic-bezier(.2,.8,.2,1);
  --t: 160ms;

  /* Typography scale */
  --font-ui: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  --fs-hero: 18px;     /* card headline */
  --fs-sub: 12px;      /* supportive text / eyebrow */
  --fs-body: 14px;     /* panel body */
  --lh-body: 1.55;

  /* Readability: max characters per line for narrative output */
  --measure: 74ch;
  --measure-chat: 84ch;

  /* Button sizing (matches billing controls) */
  --btn-min: 86px;
  --btn-primary-min: 101px;
  --btn-height: 31px;
  --btn-pad: 7px 10px;

  /* Soft edge treatment */
  --edge-soft: color-mix(in oklab, var(--border) 80%, transparent);
  --edge-hi: color-mix(in oklab, #ffffff 18%, transparent);

  /* Primary button tones (neutral, theme-aligned) */
  --primary-bg: color-mix(in oklab, #6D28D9 18%, var(--panel2));
  --primary-border: color-mix(in oklab, #6D28D9 32%, var(--border));
  --primary-text: var(--text);

  /* Mic level colors (light) */
  --mic-level-active: rgba(15, 23, 42, 0.55);
  --mic-level-idle: rgba(15, 23, 42, 0.18);
}

/* Dark theme (explicit) */
:root[data-theme="dark"]{
  --bg:#2B2B2B;
  --bg2:#2F2F2F;
  --panel:#333333;
  --panel2:#3A3A3A;
  --border: rgba(255,255,255,.10);
  --text:#EDEDED;
  --muted:#B5B5B5;

  --shadow-xs: 0 1px 1px rgba(0,0,0,.35);
  --shadow-sm: 0 1px 2px rgba(0,0,0,.45);
  --shadow-md: 0 12px 28px rgba(0,0,0,.55);
  --shadow-lg: 0 20px 50px rgba(0,0,0,.65);
  --focus: 0 0 0 3px rgba(59,130,246,.28);

  --edge-soft: color-mix(in oklab, var(--border) 58%, transparent);
  --edge-hi: color-mix(in oklab, #ffffff 8%, transparent);

  --primary-bg: color-mix(in oklab, var(--panel2) 88%, #4A4A4A);
  --primary-border: color-mix(in oklab, #ffffff 10%, transparent);
  --primary-text: var(--text);

  /* Mic level colors (dark) */
  --mic-level-active: rgba(237, 237, 237, 0.5);
  --mic-level-idle: rgba(237, 237, 237, 0.18);
}

/* Auto theme: default light, but follow OS preference */
:root[data-theme="auto"]{
  /* keep :root light defaults */
}
@media (prefers-color-scheme: dark){
  :root[data-theme="auto"]{
    --bg:#0A0F14;
    --bg2:#0D141C;
    --panel:#0F1720;
    --panel2:#101826;
    --border: rgba(255,255,255,.14);
    --text:#E5E7EB;
    --muted:#9CA3AF;

    --shadow-xs: 0 1px 1px rgba(0,0,0,.35);
    --shadow-sm: 0 1px 2px rgba(0,0,0,.45);
    --shadow-md: 0 12px 28px rgba(0,0,0,.55);
    --shadow-lg: 0 20px 50px rgba(0,0,0,.65);
    --focus: 0 0 0 3px rgba(59,130,246,.35);
  }
}

*{box-sizing:border-box}
html, body{ height:100%; }
body{
  margin:0;
  font-family: var(--font-ui);
  background: linear-gradient(180deg, var(--bg), var(--bg2));
  color:var(--text);
  font-size:15px;
  line-height:1.45;
}

.page{
  max-width:1280px;
  margin:auto;
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:16px;
}

/* Auth overlay */
.auth-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: color-mix(in oklab, var(--bg) 82%, #000000);
  z-index:200;
}
.auth-card{
  width:min(420px, 92vw);
  background: color-mix(in oklab, var(--panel2) 94%, transparent);
  border-radius:18px;
  padding:22px;
  box-shadow: var(--shadow-lg),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  display:flex;
  flex-direction:column;
  gap:14px;
}
.auth-brand{
  font-size:20px;
  font-weight:800;
  letter-spacing:.2px;
}
.auth-tabs{
  display:flex;
  gap:8px;
}
.auth-tabs button{
  flex:1;
  min-height: var(--btn-height);
  padding: var(--btn-pad);
  border-radius:12px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 88%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  font-weight:700;
}
.auth-tabs button.active{
  background: var(--primary-bg);
  color: var(--primary-text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
.auth-form{
  display:none;
  flex-direction:column;
  gap:10px;
}
.auth-form.active{
  display:flex;
}
.auth-form input{
  width:100%;
  min-height:36px;
  border-radius:12px;
  border:none;
  padding:10px 12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.auth-error{
  color: #DC2626;
  font-size:13px;
}

/* Premium cards */
.card{
  background: color-mix(in oklab, var(--panel) 92%, transparent);
  border:none;
  border-radius:var(--r);
  padding:var(--pad);
  box-shadow: var(--shadow-sm),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  transition: transform var(--t) var(--ease), box-shadow var(--t) var(--ease), border-color var(--t) var(--ease), background-color var(--t) var(--ease);
}
.card:hover{
  box-shadow: var(--shadow-md);
}

.section-title{
  font-weight:650;
  margin-bottom:10px;
  font-size:15px;
  letter-spacing:.1px;
}

/* Card header primitives */
.card-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin-bottom:8px; /* slightly tighter to give more space to main panels */
}
.card-head.transcript-head{
  flex-direction:column;
  align-items:stretch;
  gap:0;
  overflow:hidden;
}
.transcript-head-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  width:100%;
  min-width:0;
  flex-wrap:nowrap;
}
.transcript-head-right{
  display:flex;
  align-items:center;
  gap:10px;
  flex:0 0 auto;
  min-width:0;
}

.headline{
  font-size: var(--fs-hero);
  font-weight: 750;
  letter-spacing: .1px;
  line-height: 1.15;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

.subhead{
  margin-top:4px;
  font-size: var(--fs-sub);
  color: var(--muted);
}

.eyebrow{
  display:inline-flex;
  align-items:center;
  gap:8px;
  font-size: var(--fs-sub);
  color: var(--muted);
  white-space:nowrap;
  user-select:none;
}
.status-time{
  font-size: var(--fs-sub);
  color: var(--muted);
  opacity: .95;
}

.status-pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs);
}

.status-pill.live{ color: var(--danger); border-color: rgba(220,38,38,.35); background: rgba(220,38,38,.10); }
.status-pill.ok{ color: var(--ok); border-color: rgba(5,150,105,.35); background: rgba(5,150,105,.10); }
.status-pill.warn{ color: var(--warn); border-color: rgba(180,83,9,.35); background: rgba(180,83,9,.10); }

/* Premium controls */
button{
  padding:7px 10px;
  border-radius:12px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  font-size:14px;
  cursor:pointer;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  transition: transform .06s var(--ease), box-shadow var(--t) var(--ease), filter var(--t) var(--ease), opacity var(--t) var(--ease), background-color var(--t) var(--ease), border-color var(--t) var(--ease);
}
button.primary{
  background: var(--primary-bg);
  color: var(--primary-text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
button:hover:not(:disabled){
  filter: brightness(0.99);
  box-shadow: var(--shadow-sm);
}
button:disabled{
  opacity:.6;
  cursor:not-allowed;
}
button:active:not(:disabled){
  transform: translateY(1px) scale(.98);
}
button.busy{
  opacity:.65;
  filter: grayscale(1);
}
button.btn-flash{
  box-shadow: var(--focus);
}

/* Inputs */
textarea,
input[type="text"]{
  width:100%;
  border-radius:14px;
  border:none;
  padding:12px;
  resize:vertical;
  font-size:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  transition: box-shadow var(--t) var(--ease), border-color var(--t) var(--ease), background-color var(--t) var(--ease);
}
textarea::placeholder,
input[type="text"]::placeholder,
input[type="email"]::placeholder{ color: color-mix(in oklab, var(--muted) 92%, transparent); }

button:focus-visible,
textarea:focus-visible,
input[type="text"]:focus-visible,
input[type="email"]:focus-visible{
  outline:none;
  box-shadow: var(--focus),
              inset 0 0 0 1px color-mix(in oklab, var(--accent) 55%, var(--edge-soft)),
              inset 0 1px 0 var(--edge-hi);
}

.small{
  font-size:12px;
  color:var(--muted);
}

.badge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:var(--muted);
  border:none;
  border-radius:999px;
  padding:4px 9px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.badge.ok{ color: var(--ok); border-color: rgba(5,150,105,.35); background: rgba(5,150,105,.10); }
.badge.warn{ color: var(--warn); border-color: rgba(180,83,9,.35); background: rgba(180,83,9,.10); }
.badge.err{ color: var(--danger); border-color: rgba(220,38,38,.35); background: rgba(220,38,38,.10); }
.toast{
  position:fixed;
  right:18px;
  bottom:18px;
  padding:10px 14px;
  border-radius:12px;
  background: color-mix(in oklab, var(--panel2) 94%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-md),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  display:none;
  z-index:120;
  font-size:13px;
}
.toast.ok{
  color: var(--ok);
}
.toast.err{
  color: var(--danger);
}

/* =====================
   TOP BAR (Premium app header)
===================== */
.topbar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  background: var(--panel2);
}

.brand{
  display:flex;
  align-items:center;
  gap:10px;
  font-weight:700;
}
.brand-text{
  display:flex;
  flex-direction:column;
  gap:4px;
}
.brand-name{
  font-size:28px;
  line-height:1;
  letter-spacing:.2px;
}
.brand-tagline{
  font-size:12.5px;
  font-weight:500;
  color: var(--muted);
  letter-spacing:.2px;
}

.actions{
  display:flex;
  gap:10px;
  align-items:center;
  position: relative;
}
/* Only icon buttons (direct children) are forced square */
.actions > button{
  width:32px;
  height:32px;
  padding:0;
  border-radius:14px;
  font-size:13px;
  display:flex;
  align-items:center;
  justify-content:center;
}

/* Theme popover */
.popover{
  position:absolute;
  right:0;
  top:54px;
  width: 300px;
  max-width: calc(100vw - 32px);
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  border:none;
  border-radius:16px;
  box-shadow: var(--shadow-lg),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  padding:12px;
  display:none;
  z-index: 60;
}
:root[data-theme="dark"] .popover{ background: var(--panel); }
.popover h4{
  margin:0 0 10px 0;
  font-size:13px;
  font-weight:800;
  color: var(--text);
  letter-spacing:.2px;
}
.menu-popover{
  width:220px;
}
.theme-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  display:inline-block;
  position:relative;
  overflow:hidden;
  background: transparent;
}
.theme-icon::before,
.theme-icon::after{
  content:"";
  position:absolute;
  top:0;
  bottom:0;
}
.theme-icon::before{
  left:0;
  right:50%;
  background:#F8FAFC;
}
.theme-icon::after{
  left:50%;
  right:0;
  background:#0F172A;
}
.globe-icon{
  width:18px;
  height:18px;
  display:block;
  stroke-width:1.8;
  stroke-linecap:round;
  stroke-linejoin:round;
  fill:none;
  stroke: var(--text);
}
.menu-item{
  width:100%;
  text-align:left;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs);
  font-size:13px;
  font-weight:700;
}
.menu-item:hover{
  background: color-mix(in oklab, var(--panel) 70%, transparent);
}
.pop-row{
  display:flex;
  flex-direction:column;
  gap:8px;
  margin-bottom:10px;
}
.seg{
  display:flex;
  border:none;
  border-radius:14px;
  overflow:hidden;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.seg button{
  flex:1;
  border:none;
  border-right:1px solid var(--border);
  border-radius:0;
  box-shadow:none;
  background: transparent;
  padding:10px 10px;
  font-size:13px;
  font-weight:750;
}
.seg button:last-child{ border-right:none; }
.seg button.active{
  background: color-mix(in oklab, rgba(37,99,235,.18) 92%, transparent);
}
.pop-help{
  font-size:12px;
  color: var(--muted);
  line-height:1.4;
}

/* =====================
   PANELS
===================== */
.panel-white{
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  border:none;
  border-radius:14px;
  padding:12px;
  overflow:auto;
  white-space:pre-wrap;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}

/* Readability clamp (measure) */
#snapshot_panel,
#coach_panel{
  width:100%;
  max-width: var(--measure);
  margin: 0 auto;            /* centers in the panel */
  font-size: var(--fs-body);
  line-height: var(--lh-body);
}
#snapshot_panel.summary-view{
  white-space: normal;
}

/* Scrollbar polish (best-effort) */
.panel-white::-webkit-scrollbar,
.chatlog::-webkit-scrollbar,
textarea::-webkit-scrollbar{
  width:10px;
}
.panel-white::-webkit-scrollbar-thumb,
.chatlog::-webkit-scrollbar-thumb,
textarea::-webkit-scrollbar-thumb{
  background: color-mix(in oklab, var(--muted) 35%, transparent);
  border-radius:999px;
  border:3px solid transparent;
  background-clip: padding-box;
}
.panel-white::-webkit-scrollbar-track,
.chatlog::-webkit-scrollbar-track,
textarea::-webkit-scrollbar-track{
  background: transparent;
}

/* =====================
   3-COLUMN MAIN ROW
===================== */
.grid-main{
  display:grid;
  grid-template-columns: var(--colLeft) var(--colLeft) 1fr;
  gap:var(--gap);
  align-items:stretch;
}
.row-card{
  height:var(--rowH);
  display:flex;
  flex-direction:column;
  min-height:0;
}

/* =====================
   LEFT COLUMN: Transcript (top) + Snapshot (bottom)
===================== */
.left-stack{
  display:flex;
  flex-direction:column;
  gap:var(--gap);
  height:100%;
  min-height:0;
}
.stack-top{
  height: calc(var(--rowH) * var(--topFrac));
  min-height: 170px;
  display:flex;
  flex-direction:column;
  min-height:0;
}
.stack-bot{
  height: calc(var(--rowH) * var(--botFrac));
  min-height: 220px;
  display:flex;
  flex-direction:column;
  min-height:0;
}

/* =====================
   LIVE TRANSCRIPT
===================== */

.transcript-btnrow{
  display:grid;
  grid-template-columns: repeat(2, 1fr);
  gap:10px;
  align-items:stretch;
  margin-bottom:8px; /* tighter to increase transcript area */
  margin-top:0;
}
.transcript-btnrow button{
  width:100%;
  padding: var(--btn-pad);
  min-height: var(--btn-height);
  min-width: var(--btn-min);
  border-radius:12px;
  font-weight:800;
}
.transcript-btnrow button#waveform_btn{ font-weight:850; }

.transcript-status{
  display:flex;
  align-items:center;
  gap:10px;
  justify-content:flex-end;
  height:18px;
}
.mic-level-wrap{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  flex:0 0 auto;
  min-width:0;
  height:14px;
  width:120px;
}
.mic-level-canvas{
  width:100%;
  max-width:120px;
  height:14px;
  border-radius:5px;
  background: color-mix(in oklab, var(--panel2) 70%, transparent);
  display:none;
}
.mic-level-canvas.active{
  display:block;
}
.timer{
  font-size:18px;
  font-weight:700;
  line-height:18px;
  height:18px;
  display:inline-flex;
  align-items:center;
  font-variant-numeric: tabular-nums;
  letter-spacing:0.3px;
  color: var(--muted);
}
.ambient-bar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin:0 0 10px;
  padding:8px 12px;
  border-radius:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.ambient-status{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
.ambient-status-text{
  font-size:12px;
  color: var(--muted);
}
.ambient-queue{
  font-size:12px;
  color: var(--muted);
}
.ambient-actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
.ambient-actions button{
  padding:8px 12px;
  border-radius:10px;
  font-size:13px;
  min-height:32px;
}
.profile-toggle-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  border-radius:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  color: var(--text);
  font-size:14px;
}
.profile-toggle-label{
  color: var(--muted);
}
.switch{
  position:relative;
  display:inline-block;
  width:44px;
  height:24px;
}
.switch input{
  opacity:0;
  width:0;
  height:0;
}
.switch-slider{
  position:absolute;
  cursor:pointer;
  inset:0;
  background: color-mix(in oklab, var(--panel) 80%, transparent);
  border-radius:999px;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  transition: 0.2s ease;
}
.switch-slider:before{
  content:"";
  position:absolute;
  height:18px;
  width:18px;
  left:3px;
  top:3px;
  border-radius:50%;
  background: var(--text);
  transition: 0.2s ease;
}
.switch input:checked + .switch-slider{
  background: color-mix(in oklab, var(--primary) 70%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
.switch input:checked + .switch-slider:before{
  transform: translateX(20px);
}
#record_btn{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
}
#record_btn .record-btn-icon{
  display:inline-flex;
  width:18px;
  height:18px;
}
#record_btn .record-btn-icon svg{
  width:18px;
  height:18px;
  stroke: currentColor;
  fill: none;
  stroke-width: 2.2;
  stroke-linecap: round;
  stroke-linejoin: round;
}
#record_btn.record-glow{
  animation: recordGlow 2.8s ease-in-out infinite;
}
@keyframes recordGlow{
  0%{
    box-shadow: var(--shadow-xs),
                inset 0 0 0 1px var(--primary-border),
                inset 0 1px 0 var(--edge-hi),
                0 0 0 0 rgba(59,130,246,0.0);
  }
  50%{
    box-shadow: var(--shadow-xs),
                inset 0 0 0 1px var(--primary-border),
                inset 0 1px 0 var(--edge-hi),
                0 0 0 2.5px rgba(59,130,246,0.18);
  }
  100%{
    box-shadow: var(--shadow-xs),
                inset 0 0 0 1px var(--primary-border),
                inset 0 1px 0 var(--edge-hi),
                0 0 0 0 rgba(59,130,246,0.0);
  }
}

.waveform{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:12px;
  min-width:150px;
  height:44px;
  border-radius:999px;
  padding:0 18px;
  background: var(--primary-bg);
  color: var(--primary-text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
  transition: 0.2s ease;
}
.waveform-bars{
  display:flex;
  align-items:center;
  gap:4px;
}
.waveform-bar{
  width:6px;
  height:16px;
  border-radius:6px;
  background: currentColor;
  opacity:0.8;
  transform-origin:center;
  animation: wavePulse 1.2s ease-in-out infinite;
}
.waveform.recording .waveform-bar:nth-child(1){ animation-delay:0ms; }
.waveform.recording .waveform-bar:nth-child(2){ animation-delay:120ms; }
.waveform.recording .waveform-bar:nth-child(3){ animation-delay:240ms; }
.waveform.recording .waveform-bar:nth-child(4){ animation-delay:360ms; }
.waveform.recording .waveform-bar:nth-child(5){ animation-delay:480ms; }
.waveform.recording .waveform-bar:nth-child(6){ animation-delay:600ms; }
.waveform.paused{
  background: color-mix(in oklab, var(--panel) 70%, transparent);
  color: var(--muted);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.waveform.paused .waveform-bar{
  animation: none;
  opacity:0.35;
}
.waveform.initializing{
  color: var(--warn);
}
.waveform.initializing .waveform-bar{
  animation: wavePulse 1.6s ease-in-out infinite;
  opacity:0.6;
}
.waveform.error{
  color: var(--danger);
}
.waveform.error .waveform-bar{
  animation: none;
  opacity:0.5;
}
@keyframes wavePulse{
  0%{ transform: scaleY(0.4); opacity:0.4; }
  50%{ transform: scaleY(1.1); opacity:1; }
  100%{ transform: scaleY(0.5); opacity:0.6; }
}

/* Keep transcript stable; scroll inside */
.transcript-box{
  flex:1;
  min-height:0;
  resize:none;
  overflow:auto;
}

/* =====================
   SNAPSHOT
===================== */
.snapshot-box{
  flex:1;
  min-height:0;
}
.summary-section{
  margin-bottom:12px;
}
.summary-title{
  font-weight:700;
  margin:8px 0 6px;
}
.summary-line{
  margin:2px 0;
}
.summary-label{
  font-weight:650;
}
.summary-list{
  margin:4px 0 0 18px;
  padding:0;
}
.summary-list li{
  margin:0 0 4px;
}
.summary-issue{
  color: var(--danger);
  font-weight:700;
}

/* =====================
   COACH
===================== */
.coach-panel{
  flex:1;
  min-height:0;
  white-space: normal;
}
:root[data-theme="dark"] .coach-panel{
  color:#F8FAFC;
}
.coach-section{
  margin-bottom:12px;
}
.coach-title{
  font-weight:700;
  margin:8px 0 6px;
}
.coach-list{
  margin:4px 0 0 18px;
  padding:0;
}
.coach-list li{
  margin:0 0 4px;
}
.coach-cant-miss,
.coach-cant-miss .coach-title,
.coach-cant-miss li{
  color: var(--danger);
  font-weight:700;
}

/* =====================
   CLINICAL QUERY
===================== */
.query-card{
  display:flex;
  flex-direction:column;
  height:var(--rowH);
  min-height:0;
}

.chatlog{
  flex:1;
  overflow-y:auto;
  padding:12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  border-radius:14px;
  border:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  min-height:0;
  display:flex;
  flex-direction:column;
  gap:10px;
  overscroll-behavior: contain;
}

.chatinput{
  position: sticky;
  bottom: 12px;
  margin-top:12px;

  background: var(--panel2);
  border: none;
  border-radius: 16px;
  padding: 10px;
  box-shadow: var(--shadow-md),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}

/* reserve space on the right for '+' + Send */
.chatinput textarea{
  min-height:76px;
  padding-left:12px;
  padding-right:168px; /* space for + and Send */
  box-shadow: var(--shadow-xs);
  resize:none;
}

.send-btn{
  position:absolute;
  bottom:20px;
  right:20px;
  padding:6px 10px;
  border-radius:12px;
  border:none;
  background: var(--primary-bg);
  color: var(--primary-text);
  min-width:52px;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}

.query-actions{
  display:flex;
  gap:12px;
  justify-content:flex-start;
  margin-top:12px;
  flex-wrap:wrap;
}
.query-actions button.primary{
  min-width: var(--btn-primary-min);
  min-height: var(--btn-height);
  padding: var(--btn-pad);
}
.macro-row{
  display:flex;
  align-items:center;
  margin-top:10px;
}
.macro-row select{
  width:100%;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  border:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  font-size: var(--fs-body);
}
.macro-row select option{
  color: var(--text);
  background: var(--panel);
}

.macro-overlay{
  position:fixed;
  inset:0;
  background: rgba(10,16,24,.55);
  backdrop-filter: blur(3px);
  -webkit-backdrop-filter: blur(3px);
  z-index:80;
}
.macro-panel{
  position:fixed;
  top:20px;
  right:20px;
  width:min(520px, 92vw);
  height:calc(100vh - 40px);
  display:flex;
  flex-direction:column;
  gap:12px;
  overflow:auto;
  padding:16px;
  border-radius:20px;
  border:1px solid var(--border);
  background: color-mix(in oklab, var(--panel) 96%, transparent);
  box-shadow: var(--shadow-lg);
  z-index:90;
}
.about-panel{
  width:min(720px, 94vw);
}
.about-body{
  display:flex;
  flex-direction:column;
  gap:10px;
  font-size: var(--fs-body);
  line-height: var(--lh-body);
  color: var(--text);
}
.about-poem{
  white-space: pre-line;
}
.feedback-panel{
  width:min(560px, 92vw);
}
.feedback-panel .macro-section{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.feedback-panel input[type="email"]{
  width:100%;
  border-radius:14px;
  border:none;
  padding:12px;
  font-size:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
#feedbackMessage{
  min-height:180px;
  resize:none;
}
.profile-panel{
  width:min(560px, 92vw);
}
.profile-panel .macro-section{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.kb-panel{
  width:min(640px, 94vw);
}
.kb-tabs{
  display:flex;
  gap:8px;
  padding:0 16px 6px;
}
.kb-tab{
  border-radius:999px;
  border:none;
  padding:8px 14px;
  font-size:13px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  cursor:pointer;
}
.kb-tab.active{
  background: color-mix(in oklab, var(--accent) 24%, var(--panel2));
}
.kb-panel .macro-section{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.kb-panel input{
  width:100%;
  border-radius:14px;
  border:none;
  padding:12px;
  font-size:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.kb-site-list{
  display:flex;
  flex-direction:column;
  gap:10px;
  font-size:13px;
  color: var(--text);
}
.kb-site-item{
  padding:10px 12px;
  border-radius:12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.kb-site-meta{
  font-size:12px;
  color: var(--muted);
  margin-top:4px;
}
.kb-guideline-panel{
  width:min(980px, 96vw);
}
.kb-guideline-body{
  display:grid;
  grid-template-columns: 1fr 1.3fr;
  gap:14px;
  padding:0 16px 16px;
}
.kb-guideline-asset{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.kb-guideline-asset iframe{
  width:100%;
  min-height:380px;
  border-radius:14px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.kb-guideline-editor{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.kb-editor-list{
  display:flex;
  flex-direction:column;
  gap:8px;
  max-height:260px;
  overflow:auto;
  padding-right:4px;
}
.kb-editor-row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:8px;
}
.kb-editor-row input,
.kb-editor-row select,
.kb-editor-row textarea{
  width:100%;
  border-radius:12px;
  border:none;
  padding:8px 10px;
  font-size:12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.kb-editor-row textarea{
  min-height:42px;
  resize:none;
}
.profile-panel input{
  width:100%;
  border-radius:14px;
  border:none;
  padding:12px;
  font-size:14px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.profile-panel select{
  width:100%;
  border:none;
  padding:0;
  font-size:14px;
  line-height:20px;
  background: transparent;
  color: var(--text);
  text-align: center;
  text-align-last: center;
}
.profile-select-shell{
  width:100%;
  border-radius:14px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  min-height:48px;
  padding:12px;
  display:flex;
  align-items:center;
}
.profile-clinic-group{
  width:100%;
  border-radius:14px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}
.profile-clinic-group input{
  background: transparent;
  border:none;
  box-shadow:none;
  border-radius:0;
  padding:10px 12px;
  font-size:14px;
  color: var(--text);
}
.profile-clinic-group input + input{
  border-top:1px solid var(--edge-soft);
}
.referral-panel{
  width:min(760px, 94vw);
}
.referral-toolbar{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  margin:0 12px 8px 12px;
  border-radius:14px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.referral-toolbar label{
  font-size:13px;
  color: var(--muted);
  white-space:nowrap;
}
.referral-toolbar input{
  flex:1;
  border-radius:12px;
  border:none;
  padding:10px 12px;
  font-size:14px;
  background: color-mix(in oklab, var(--panel) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
#referralMissing{
  white-space:pre-line;
}
.referral-editor{
  position:relative;
}
.referral-letter{
  flex:1;
  min-height:360px;
  padding:12px;
  border-radius:16px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  font-size: var(--fs-body);
  line-height: var(--lh-body);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  overflow:auto;
  white-space:pre-wrap;
}
.referral-letter:focus{
  outline:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
.note-draft-panel{
  width:min(760px, 94vw);
}
.note-draft-editor{
  position:relative;
}
.note-draft-letter{
  width:100%;
  min-height:360px;
  padding:12px;
  border-radius:16px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  font-size: var(--fs-body);
  line-height: var(--lh-body);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  overflow:auto;
  white-space:pre-wrap;
  resize:none;
}
.note-draft-letter:focus{
  outline:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
.referral-loading{
  position:absolute;
  inset:64px 0 auto 0;
  display:none;
  align-items:center;
  flex-direction:row;
  justify-content:center;
  gap:8px;
  padding:8px 12px;
  width:fit-content;
  margin:0 auto;
  background: color-mix(in oklab, var(--panel) 78%, transparent);
  backdrop-filter: blur(6px);
  border-radius:999px;
  z-index:2;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.referral-loading.active{
  display:flex;
}
.referral-spinner{
  width:18px;
  height:18px;
  border-radius:50%;
  border:2px solid color-mix(in oklab, var(--muted) 70%, transparent);
  border-top-color: var(--primary-border);
  animation: referralSpin 0.9s linear infinite;
}
.referral-loading-text{
  font-size:11px;
  color: var(--muted);
}
.referral-skeleton{
  display:none;
}
.referral-skeleton span{
  height:10px;
  border-radius:999px;
  background: linear-gradient(90deg,
    color-mix(in oklab, var(--panel2) 80%, transparent),
    color-mix(in oklab, var(--panel2) 60%, transparent),
    color-mix(in oklab, var(--panel2) 80%, transparent));
  background-size:200% 100%;
  animation: referralShimmer 1.4s ease-in-out infinite;
}
.referral-skeleton span:nth-child(2){ width:92%; }
.referral-skeleton span:nth-child(3){ width:84%; }
.referral-skeleton span:nth-child(4){ width:76%; }
.missing-critical{
  color: var(--danger);
  font-weight:650;
}
.note-log-panel{
  width:min(980px, 94vw);
  height:min(82vh, 720px);
  display:flex;
  flex-direction:column;
  gap:12px;
}
.note-log-body{
  display:grid;
  grid-template-columns: minmax(220px, 1fr) minmax(360px, 1.7fr);
  gap:12px;
  flex:1;
  min-height:0;
}
.note-log-list{
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0;
}
.note-log-list input{
  width:100%;
  border-radius:12px;
  border:none;
  padding:8px 10px;
  font-size:13px;
  background: color-mix(in oklab, var(--panel) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.note-log-items{
  display:flex;
  flex-direction:column;
  gap:8px;
  overflow:auto;
  min-height:0;
}
.note-log-item{
  text-align:left;
  padding:10px 12px;
  border-radius:12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color: var(--text);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.note-log-item.active{
  box-shadow: var(--shadow-sm),
              inset 0 0 0 1px var(--primary-border),
              inset 0 1px 0 var(--edge-hi);
}
.note-log-item-title{
  font-weight:650;
  font-size:13px;
}
.note-log-item-sub{
  font-size:12px;
  color: var(--muted);
  margin-top:4px;
}
.note-log-detail{
  display:flex;
  flex-direction:column;
  gap:10px;
  min-height:0;
}
.note-log-section{
  flex:1;
  min-height:0;
  font-size: var(--fs-body);
  line-height: var(--lh-body);
}
@keyframes referralSpin{
  to { transform: rotate(360deg); }
}
@keyframes referralShimmer{
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}
.confirm-panel{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%, -50%);
  width:min(420px, 92vw);
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:16px;
  border-radius:18px;
  border:none;
  background: color-mix(in oklab, var(--panel) 96%, transparent);
  box-shadow: var(--shadow-lg),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  z-index:100;
}
.confirm-title{
  font-size:16px;
  font-weight:750;
}
.confirm-body{
  font-size:13px;
  color: var(--muted);
  line-height:1.4;
}
.confirm-actions{
  display:flex;
  justify-content:flex-end;
  gap:10px;
  margin-top:4px;
}
.confirm-actions button{
  min-width: var(--btn-min);
  min-height: var(--btn-height);
  padding: var(--btn-pad);
}
.confirm-actions button.primary{
  min-width: var(--btn-primary-min);
}
.macro-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
}
.macro-head button{
  width:26px;
  height:26px;
  border-radius:12px;
  padding:0;
}
.macro-section{
  border:none;
  border-radius:16px;
  padding:12px;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.macro-editor{
  flex:1;
  min-height:0;
  display:flex;
  flex-direction:column;
}
.macro-picker{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:nowrap;
}
.macro-picker select{
  flex:1 1 auto;
  min-width:0;
  background: color-mix(in oklab, var(--panel) 92%, transparent);
  color: var(--text);
  font-size: var(--fs-body);
  border:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.macro-picker button{
  flex:0 0 auto;
  min-width: var(--btn-min);
  min-height: var(--btn-height);
  padding: var(--btn-pad);
}
.macro-picker button.primary{
  min-width: var(--btn-primary-min);
}
.macro-picker select option{
  color: var(--text);
  background: var(--panel);
}
.macro-section:first-of-type{
  padding-bottom:0;
}
.macro-label{
  display:block;
  margin-top:8px;
  font-size:12px;
  color:var(--muted);
}
.macro-section input,
.macro-section textarea{
  width:100%;
}
.macro-section textarea{
  min-height:240px;
  resize:vertical;
}
.macro-editor textarea{
  flex:1;
  min-height:340px;
}

.billing-archive-row{
  display:flex;
  gap:8px;
  align-items:center;
}
.billing-archive-row select{
  flex:1 1 auto;
  min-width:0;
  background: color-mix(in oklab, var(--panel) 92%, transparent);
  color: var(--text);
  font-size: var(--fs-body);
  border:none;
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}
.billing-archive-row select option{
  color: var(--text);
  background: var(--panel);
}
.billing-archive-panel textarea{
  resize:none;
}
.billing-archive-panel{
  width:min(640px, 94vw);
}
.macro-editor .summary-title{
  margin-top:2px;
  margin-bottom:4px;
}
#macroContentInput{
  margin-top:10px;
  resize:none;
}
.macro-editor-actions{
  display:flex;
  justify-content:flex-end;
  gap:8px;
  margin-top:6px;
}
.macro-editor-actions button{
  min-width: var(--btn-min);
  min-height: var(--btn-height);
  padding: var(--btn-pad);
}
.macro-editor-actions button.primary{
  min-width: var(--btn-primary-min);
}
.macro-status{
  min-height:0;
  margin-top:4px;
  font-size:12px;
  color:var(--muted);
}
.macro-status.error{
  color:var(--danger);
}

/* =====================
   CHAT BUBBLES
===================== */
.msg{ display:flex; width:100%; }
.msg.user{ justify-content:flex-end; }
.msg.assistant{ justify-content:flex-start; }
.msg.system{ justify-content:center; }

.bubble{
  max-width:78%;
  padding:10px 12px;
  border-radius:18px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
  white-space:pre-wrap;
  font-size: var(--fs-body);
  line-height: 1.45;
}

/* Clamp assistant bubbles to a readable measure */
.msg.assistant .bubble{
  max-width: min(78%, var(--measure-chat));
}

.msg.user .bubble{
  background: color-mix(in oklab, rgba(37,99,235,.18) 90%, var(--panel2));
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px color-mix(in oklab, rgba(37,99,235,.25) 70%, var(--edge-soft)),
              inset 0 1px 0 var(--edge-hi);
}

.msg.system .bubble{
  background: color-mix(in oklab, var(--panel) 70%, transparent);
  color:var(--muted);
  border:none;
  font-size:13px;
  max-width:92%;
}

.bubble-meta{
  font-size:12px;
  color:var(--muted);
  margin-bottom:6px;
}

.muted{
  color: var(--muted);
  font-size:12px;
}


.mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

/* =====================
   BILLING (SIMPLIFIED)
===================== */
.billing-text{
  margin-top: 10px;
  min-height: 260px;
  resize: none;
  white-space: pre-wrap;
}

.billing-date{
  font-size: var(--fs-body);
  color:var(--muted);
  letter-spacing:.2px;
}

.billing-meta{
  display:flex;
  align-items:center;
  gap:10px;
  margin-top:10px;
}
.billing-meta select{
  padding:8px 10px;
  border-radius:10px;
  border:none;
  background: color-mix(in oklab, var(--panel2) 96%, transparent);
  color:var(--text);
  font-size: var(--fs-body);
  box-shadow: var(--shadow-xs),
              inset 0 0 0 1px var(--edge-soft),
              inset 0 1px 0 var(--edge-hi);
}

.billing-actions{
  display:flex;
  gap:10px;
  justify-content:flex-end;
  margin-top:10px;
  flex-wrap:wrap;
}
.billing-actions button{
  min-width: var(--btn-min);
  min-height: var(--btn-height);
  padding: var(--btn-pad);
}
.billing-actions .save-primary{ min-width: var(--btn-primary-min); }

@media (max-width: 980px){
  .billing-actions{ justify-content:stretch; }
  .billing-actions button{ flex:1; }
}

/* =====================
   FOOTER
===================== */
.footer{
  text-align:center;
  font-size:12px;
  color:var(--muted);
  padding:12px 0 4px;
}

/* =====================
   RESPONSIVE
===================== */
@media (max-width: 1100px){
  :root{
    --rowH: 900px;
    --colLeft: 1fr;
  }
  .grid-main{ grid-template-columns: 1fr; }
  .row-card, .query-card{ height:auto; }
  .transcript-box{ resize:vertical; }
  .stack-top, .stack-bot{ height:auto; }
  .transcript-btnrow{ grid-template-columns: 1fr; }
  .cq-draft-name{ max-width: 220px; }
  .chatinput{ position: relative; bottom: auto; }
  .popover{ right:0; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  *{ transition: none !important; scroll-behavior: auto !important; }
}
</style>
</head>

<body>
<div id="authOverlay" class="auth-overlay" style="display:none">
  <div class="auth-card">
    <div class="auth-brand">CentaurMD</div>
    <div class="auth-tabs">
      <button id="authTabLogin" type="button" class="active">Login</button>
      <button id="authTabSignup" type="button">Sign up</button>
    </div>
    <div id="authError" class="auth-error" style="display:none"></div>
    <form id="authLoginForm" class="auth-form active" autocomplete="on">
      <input id="authLoginUsername" type="text" placeholder="Username" autocomplete="username" />
      <input id="authLoginPassword" type="password" placeholder="Password" autocomplete="current-password" />
      <button id="authLoginBtn" type="submit" class="primary">Login</button>
    </form>
    <form id="authSignupForm" class="auth-form" autocomplete="on">
      <input id="authSignupUsername" type="text" placeholder="Username" autocomplete="username" />
      <input id="authSignupEmail" type="email" placeholder="Email" autocomplete="email" />
      <input id="authSignupPassword" type="password" placeholder="Password (min 8 chars)" autocomplete="new-password" />
      <button id="authSignupBtn" type="submit" class="primary">Create account</button>
    </form>
  </div>
</div>
<div class="page">
  <!-- TOP BAR -->
  <div class="card topbar">
    <div class="brand">
      <div class="brand-text">
        <span class="brand-name">CentaurMD</span>
        <span class="brand-tagline">Built by family physicians.</span>
      </div>
    </div>
    <div class="actions">
      <button id="globalCopyBtn" type="button" title="Copy full context" aria-label="Copy full context">
        <svg class="globe-icon" viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="12" r="9"></circle>
          <path d="M3 12h18"></path>
          <path d="M12 3a9 9 0 0 0 0 18"></path>
          <path d="M12 3a9 9 0 0 1 0 18"></path>
          <path d="M5.2 7.5c2.2 1.1 4.6 1.7 6.8 1.7 2.2 0 4.6-.6 6.8-1.7"></path>
          <path d="M5.2 16.5c2.2-1.1 4.6-1.7 6.8-1.7 2.2 0 4.6.6 6.8 1.7"></path>
        </svg>
      </button>
      <button id="themeBtn" type="button" title="Toggle theme" aria-label="Toggle theme">
        <span class="theme-icon" aria-hidden="true"></span>
      </button>
      <button id="menuBtn" type="button" title="Menu" aria-label="Menu">â˜°</button>
      <button id="profileBtn" type="button" title="Account" aria-label="Account">ðŸ‘¤</button>

      <div id="menuPopover" class="popover menu-popover" role="dialog" aria-label="Menu" style="display:none">
        <div class="pop-row" style="margin-bottom:0;">
          <button id="macroBuilderBtn" type="button" class="menu-item">Template builder</button>
          <button id="noteLogBtn" type="button" class="menu-item" style="display:none">Note Log</button>
          <button id="feedbackBtn" type="button" class="menu-item">Feedback</button>
          <button id="aboutBtn" type="button" class="menu-item">About</button>
        </div>
      </div>
      <div id="profilePopover" class="popover menu-popover" role="dialog" aria-label="Account" style="display:none">
        <div class="pop-row" style="margin-bottom:0;">
          <button id="signOutBtn" type="button" class="menu-item">Sign out</button>
          <button id="reviewBillingBtn" type="button" class="menu-item">Review saved billings</button>
          <button id="personalizationBtn" type="button" class="menu-item">Personalization</button>
          <button id="localKbBtn" type="button" class="menu-item" style="display:none">Local Knowledge Base</button>
          <button id="coachReportBtn" type="button" class="menu-item">Coach Report</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MAIN ROW: (LEFT STACK) | COACH | CLINICAL QUERY -->
  <div class="grid-main">
    <!-- LEFT STACK -->
    <div class="card row-card">
      <div class="left-stack">
        <!-- TOP: LIVE TRANSCRIPT -->
        <div class="stack-top">
          <div class="card-head transcript-head">
            <div class="transcript-head-row">
              <div class="headline">Live Transcript</div>
              <div class="transcript-head-right" aria-label="Recording status">
                <div class="mic-level-wrap">
                  <canvas class="mic-level-canvas" id="micLevelCanvas" width="120" height="14" aria-hidden="true"></canvas>
                </div>
                <div class="eyebrow transcript-status">
                  <span class="timer" id="recordTimer">00:00</span>
                </div>
              </div>
            </div>
            <div class="subhead">Speak in any language.</div>
          </div>

          <div class="transcript-btnrow">
            <button id="record_btn" type="button" class="primary record-glow">
              <span class="record-btn-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24">
                  <rect x="9" y="3" width="6" height="10" rx="3"></rect>
                  <path d="M5 10v2a7 7 0 0 0 14 0v-2"></path>
                  <path d="M12 19v2"></path>
                  <path d="M8 21h8"></path>
                </svg>
              </span>
              <span id="record_btn_label">Record</span>
            </button>
            <button id="new_patient_btn" type="button">New</button>
          </div>

          <textarea class="transcript-box" id="transcript_box" placeholder="Live transcript will appear hereâ€¦" spellcheck="false"></textarea>
        </div>

        <!-- BOTTOM: PATIENT SNAPSHOT -->
        <div class="stack-bot">
          <div class="card-head" style="margin:0 0 10px 0;">
            <div>
              <div class="headline">Hallway Summary</div>
              <div class="subhead">Patient's "Know-Me" Snapshot</div>
            </div>
            <div class="eyebrow">
              <span class="status-pill ok" id="snap_state" style="display:none">READY</span>
            </div>
          </div>
          <div class="panel-white snapshot-box" id="snapshot_panel"></div>
        </div>
      </div>
    </div>

    <!-- COACH -->
    <div class="card row-card">
      <div class="card-head">
        <div>
          <div class="headline">Coach</div>
          <div class="subhead">Real-time DDx coaching</div>
        </div>
        <div class="eyebrow"></div>
      </div>
      <div class="panel-white coach-panel" id="coach_panel"></div>
    </div>

    <!-- CLINICAL QUERY -->
    <div class="card query-card" id="query_card">
      <div class="card-head">
        <div>
          <div class="headline">Clinical Query</div>
          <div class="subhead">Up-to-date Canada-Alberta guideline based answers at point-of-care.</div>
        </div>
        <div class="eyebrow"></div>
      </div>

      <div class="chatlog" aria-live="polite"></div>

      <div class="chatinput" id="cqChatInputWrap">
        <textarea id="cqTextArea" placeholder="Ask a clinical question, or paste EMR/backgroundâ€¦" spellcheck="false"></textarea>
        <button class="send-btn" id="cqSendBtn" type="button">Send</button>
      </div>

      <div class="query-actions">
        <button class="primary" type="button" id="soapBtn">SOAP</button>
        <button class="primary" type="button" id="referralBtn">Referral</button>
        <button class="primary" type="button" id="rxBtn">Rx</button>
      </div>

      <div class="macro-row">
        <select id="macroSelect">
          <option value="">Templates</option>
        </select>
      </div>
    </div>
  </div>

  <!-- BILLING PANEL (SIMPLIFIED) -->
  <div class="card" id="billingCard">
    <div class="card-head" style="margin-bottom:0;">
      <div>
        <div class="headline">Billing</div>
        <div class="subhead">Auto populate ICD-9 and billing codes</div>
      </div>
      <div class="billing-date" id="billingDate"></div>
    </div>

    <div class="billing-meta">
      <select id="billingModelSelect">
        <option value="FFS">Fee for Service (FFS)</option>
        <option value="PCPCM">Primary Care Physician Compensation Model (PCPCM)</option>
      </select>
    </div>

    <textarea id="dailyBillingText"
              class="billing-text"
              placeholder="Daily billing list (editable)"
              spellcheck="false"></textarea>

    <div class="billing-actions">
      <button id="billBtn" type="button">Bill</button>
      <button id="saveBillingBtn" class="primary save-primary" type="button">Save</button>
      <button id="printBillingBtn" type="button">Print</button>
    </div>
  </div>

  <div class="footer">
    Â© 2026 Centaur Systems. All rights reserved.
  </div>
</div>

<div id="macroOverlay" class="macro-overlay" style="display:none"></div>
<div id="macroPanel" class="macro-panel" style="display:none" aria-label="Template builder">
  <div class="macro-head">
    <div class="headline">Template Builder</div>
    <button id="macroCloseBtn" type="button">âœ•</button>
  </div>

  <div class="macro-section">
    <div class="macro-picker">
      <select id="macroPickerSelect"></select>
      <button id="macroEditBtn" type="button">Edit</button>
      <button id="macroDeleteBtn" type="button">Delete</button>
      <button id="macroAddBtn" class="primary" type="button">+ New template</button>
    </div>
  </div>

  <div class="macro-section macro-editor">
    <div class="summary-title">Editor</div>
    <input id="macroNameInput" type="text" placeholder="Template name" />
    <textarea id="macroContentInput" placeholder="Paste template content"></textarea>
    <div id="macroStatus" class="macro-status"></div>
    <div class="macro-editor-actions">
      <button id="macroSaveBtn" class="primary" type="button">Save</button>
      <button id="macroCancelBtn" type="button">Cancel</button>
    </div>
  </div>
</div>
<div id="aboutOverlay" class="macro-overlay" style="display:none"></div>
<div id="aboutPanel" class="macro-panel about-panel" style="display:none" aria-label="About CentaurMD">
  <div class="macro-head">
    <h2>About</h2>
    <button id="aboutCloseBtn" type="button">âœ•</button>
  </div>
  <div class="macro-section">
    <div class="about-body">
      <div class="about-poem">It listens for what matters, not just what's said,
then shapes the visit into SOAP you'll want reread--
carries the thread to referral letters, clear and true,
templates that sound like you, and notes cross-checked by two.

Before you knock, it hands you context, quick and bright:
a ten-second "Know-Me" snapshot--set you right.
Names and kin, work and wins, the worries in the noise,
the human facts that turn a chart to an actual voice--
so even if the patient's new to you today,
you don't walk in cold; you walk in the right way.

In the room it stays beside you--quiet, clinical, near:
a DDx coach to sharpen what you're thinking, steer.
A chart-query that answers from the record you already keep,
and Alberta/Canada guidance, linked--so you can verify deep.
When the question isn't "what do I remember?" in a rush,
but "what fits this patient, now?"--it gives the clearest brush.

It checks what must be checked before the plan is signed:
allergies, interactions--med risks you can't leave behind.
Then brings the visit home with billing that makes sense:
ICD-9 and codes suggested from your actual evidence--
so the work you truly did is visible, clean, complete,
consistent across the day, from hallway to the charting seat.

It is the space between the rush and the recall,
the bridge from encounter to continuity for all--
built for the realities family physicians live,
and for the care, day after day, you give.</div>
    </div>
  </div>
</div>
<div id="feedbackOverlay" class="macro-overlay" style="display:none"></div>
<div id="feedbackPanel" class="macro-panel feedback-panel" style="display:none" aria-label="Feedback">
  <div class="macro-head">
    <h2>Feedback</h2>
    <button id="feedbackCloseBtn" type="button">âœ•</button>
  </div>
  <div class="macro-section">
    <input id="feedbackEmail" type="email" placeholder="Your email" />
    <textarea id="feedbackMessage" placeholder="Write feedback..."></textarea>
    <div id="feedbackStatus" class="macro-status"></div>
    <div class="macro-editor-actions">
      <button id="feedbackSendBtn" class="primary" type="button">Send</button>
      <button id="feedbackCancelBtn" type="button">Cancel</button>
    </div>
  </div>
</div>
<div id="profileOverlay" class="macro-overlay" style="display:none"></div>
<div id="profilePanel" class="macro-panel profile-panel" style="display:none" aria-label="Personalization">
  <div class="macro-head">
    <h2>Personalization</h2>
    <button id="profileCloseBtn" type="button">âœ•</button>
  </div>
  <div class="macro-section">
    <input id="profileSignatureName" type="text" placeholder="Signature Name" />
    <input id="profileCpsa" type="text" placeholder="CPSA Number" />
    <div class="profile-select-shell">
      <select id="profileDefaultFundingModel">
        <option value="">Default funding model</option>
        <option value="FFS">Fee for Service (FFS)</option>
        <option value="PCPCM">Primary Care Physician Compensation Model (PCPCM)</option>
      </select>
    </div>
    <div class="profile-clinic-group">
      <input id="profileClinicName" type="text" placeholder="Clinic Name" />
      <input id="profileClinicAddress" type="text" placeholder="Clinic Address" />
      <input id="profileClinicPhone" type="text" placeholder="Clinic Phone" />
      <input id="profileClinicFax" type="text" placeholder="Clinic Fax" />
    </div>
    <div id="profileStatus" class="macro-status"></div>
    <div class="macro-editor-actions">
      <button id="profileSaveBtn" class="primary" type="button">Save</button>
      <button id="profileCancelBtn" type="button">Cancel</button>
    </div>
  </div>
</div>
<div id="kbOverlay" class="macro-overlay" style="display:none"></div>
<div id="kbPanel" class="macro-panel kb-panel" style="display:none" aria-label="Local Knowledge Base">
  <div class="macro-head">
    <h2>Local Knowledge Base</h2>
    <button id="kbCloseBtn" type="button">âœ•</button>
  </div>
  <div class="kb-tabs">
    <button id="kbSitesTab" type="button" class="kb-tab active">Sites</button>
    <button id="kbGuidelinesTab" type="button" class="kb-tab">Guideline Algorithms</button>
  </div>
  <div id="kbSitesView">
    <div class="macro-section">
      <input id="kbUrlInput" type="text" placeholder="Enter site URL (e.g., https://rxfiles.ca)" />
      <div id="kbStatus" class="macro-status"></div>
      <div class="macro-editor-actions">
        <button id="kbIndexBtn" class="primary" type="button">Index site</button>
        <button id="kbRefreshBtn" type="button">Refresh list</button>
      </div>
    </div>
    <div class="macro-section">
      <div class="summary-title">Indexed sites</div>
      <div id="kbSiteList" class="kb-site-list"></div>
    </div>
  </div>
  <div id="kbGuidelinesView" style="display:none">
    <div class="macro-section">
      <div class="summary-title">Extracted guidelines</div>
      <div id="kbGuidelineList" class="kb-site-list"></div>
      <div id="kbGuidelineStatus" class="macro-status"></div>
      <div class="macro-editor-actions">
        <button id="kbGuidelineRefreshBtn" type="button">Refresh list</button>
      </div>
    </div>
  </div>
</div>
<div id="kbGuidelineOverlay" class="macro-overlay" style="display:none"></div>
<div id="kbGuidelinePanel" class="macro-panel kb-guideline-panel" style="display:none" aria-label="Guideline QA">
  <div class="macro-head">
    <h2>Guideline QA</h2>
    <button id="kbGuidelineCloseBtn" type="button">âœ•</button>
  </div>
  <div class="kb-guideline-body">
    <div class="kb-guideline-asset">
      <div class="summary-title">Source</div>
      <a id="kbGuidelineSourceLink" href="#" target="_blank" rel="noopener">Open source</a>
      <iframe id="kbGuidelineFrame" title="Guideline source"></iframe>
    </div>
    <div class="kb-guideline-editor">
      <div class="summary-title">Nodes</div>
      <div id="kbGuidelineNodes" class="kb-editor-list"></div>
      <button id="kbGuidelineAddNode" type="button">Add node</button>
      <div class="summary-title">Edges</div>
      <div id="kbGuidelineEdges" class="kb-editor-list"></div>
      <button id="kbGuidelineAddEdge" type="button">Add edge</button>
      <div id="kbGuidelineEditStatus" class="macro-status"></div>
      <div class="macro-editor-actions">
        <button id="kbGuidelineSaveBtn" class="primary" type="button">Save Patch</button>
        <button id="kbGuidelineReextractBtn" type="button">Re-extract</button>
        <button id="kbGuidelineCloseBtn2" type="button">Close</button>
      </div>
    </div>
  </div>
</div>
<div id="referralOverlay" class="macro-overlay" style="display:none"></div>
<div id="referralPanel" class="macro-panel referral-panel" style="display:none" aria-label="Referral Draft">
  <div class="macro-head">
    <h2>Referral Draft</h2>
    <button id="referralCloseBtn" type="button">âœ•</button>
  </div>
  <div class="referral-toolbar">
    <label for="referralSpecialtyInput">Refer to:</label>
    <input id="referralSpecialtyInput" type="text" placeholder="" />
    <button id="referralGenerateBtn" class="primary" type="button">Generate Referral</button>
  </div>
  <div class="macro-section macro-editor referral-editor">
    <div class="summary-title">Draft Letter</div>
    <div id="referralLoading" class="referral-loading" aria-hidden="true">
      <div class="referral-spinner"></div>
      <div class="referral-loading-text">Generating draftâ€¦</div>
      <div class="referral-skeleton">
        <span></span><span></span><span></span><span></span>
      </div>
    </div>
    <div id="referralLetterText" class="referral-letter" contenteditable="true" aria-label="Referral draft"></div>
    <div id="referralMissing" class="macro-status"></div>
    <div id="referralStatus" class="macro-status"></div>
    <div class="macro-editor-actions">
      <button id="referralCopyBtn" class="primary" type="button">Copy</button>
      <button id="referralCloseBtn2" type="button">Close</button>
    </div>
  </div>
</div>
<div id="noteDraftOverlay" class="macro-overlay" style="display:none"></div>
<div id="noteDraftPanel" class="macro-panel referral-panel note-draft-panel" style="display:none" aria-label="Note Draft" role="dialog" aria-modal="true" aria-labelledby="noteDraftTitle" tabindex="-1">
  <div class="macro-head">
    <div class="headline" id="noteDraftTitle">Note</div>
    <button id="noteDraftCloseBtn" type="button">âœ•</button>
  </div>
  <div class="macro-section macro-editor note-draft-editor">
    <div id="noteDraftLoading" class="referral-loading" aria-hidden="true">
      <div class="referral-spinner"></div>
      <div class="referral-loading-text">Generatingâ€¦</div>
    </div>
    <textarea id="noteDraftText" class="note-draft-letter" spellcheck="false"></textarea>
    <div id="noteDraftStatus" class="macro-status"></div>
    <div class="macro-editor-actions">
      <button id="noteDraftCopyBtn" class="primary" type="button">Copy</button>
      <button id="noteDraftCloseBtn2" type="button">Close</button>
    </div>
  </div>
</div>
<div id="noteLogOverlay" class="macro-overlay" style="display:none"></div>
<div id="noteLogPanel" class="macro-panel note-log-panel" style="display:none" aria-label="Note Log">
  <div class="macro-head">
    <div class="headline">Note Log</div>
    <button id="noteLogCloseBtn" type="button">âœ•</button>
  </div>
  <div class="note-log-body">
    <div class="note-log-list panel-white">
      <input id="noteLogSearch" type="text" placeholder="Search name or complaint" />
      <div id="noteLogList" class="note-log-items"></div>
    </div>
    <div class="note-log-detail">
      <div class="seg note-log-tabs">
        <button id="noteLogTabOutputs" type="button" class="active">Outputs</button>
        <button id="noteLogTabInputs" type="button">Inputs</button>
        <button id="noteLogTabMeta" type="button">Metadata</button>
      </div>
      <div id="noteLogOutputs" class="panel-white note-log-section" aria-label="Note log outputs"></div>
      <div id="noteLogInputs" class="panel-white note-log-section" style="display:none" aria-label="Note log inputs"></div>
      <div id="noteLogMeta" class="panel-white note-log-section" style="display:none" aria-label="Note log metadata"></div>
      <div id="noteLogStatus" class="macro-status"></div>
      <div class="macro-editor-actions">
        <button id="noteLogDeleteBtn" type="button">Delete</button>
        <button id="noteLogCloseBtn2" type="button">Close</button>
      </div>
    </div>
  </div>
</div>
<div id="toast" class="toast" role="status" aria-live="polite"></div>

<div id="billingArchiveOverlay" class="macro-overlay" style="display:none"></div>
<div id="billingArchivePanel" class="macro-panel billing-archive-panel" style="display:none" aria-label="Saved billings">
  <div class="macro-head">
    <div class="headline">Saved Billings</div>
    <button id="billingArchiveCloseBtn" type="button">âœ•</button>
  </div>

  <div class="macro-section">
    <div class="billing-archive-row">
      <select id="billingArchiveSelect"></select>
      <button id="billingArchiveRefreshBtn" type="button">Refresh</button>
      <button id="billingArchiveDeleteBtn" type="button">Delete</button>
    </div>
    <div id="billingArchiveMeta" class="macro-status"></div>
  </div>

  <div class="macro-section macro-editor">
    <textarea id="billingArchiveText" placeholder="Select a saved billing to review or edit"></textarea>
    <div class="macro-editor-actions">
      <button id="billingArchiveSaveBtn" class="primary" type="button">Save</button>
      <button id="billingArchivePrintBtn" type="button">Reprint</button>
    </div>
  </div>
</div>

<div id="newPatientConfirmOverlay" class="macro-overlay" style="display:none"></div>
<div id="newPatientConfirmPanel" class="confirm-panel" style="display:none" role="dialog" aria-modal="true" aria-labelledby="newPatientConfirmTitle">
  <div class="confirm-title" id="newPatientConfirmTitle">Billing not generated</div>
  <div class="confirm-body">Please generate billing for the current patient before starting a new one. Continue anyway?</div>
  <div class="confirm-actions">
    <button id="newPatientConfirmCancelBtn" type="button">Cancel</button>
    <button id="newPatientConfirmProceedBtn" class="primary" type="button">New anyway</button>
  </div>
</div>

<script>
const API_BASE = "/api";
const CHUNK_MS = 12000;

// fetch hardening
const FETCH_TIMEOUT_MS = 45000;
function fetchWithTimeout(url, opts = {}, timeoutMs = FETCH_TIMEOUT_MS) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);

  const merged = {
    credentials: "same-origin",
    cache: "no-store",
    ...opts,
    headers: {
      "Accept": "application/json, text/plain, */*",
      ...(opts.headers || {}),
    },
    signal: controller.signal,
  };

  return fetch(url, merged).finally(() => clearTimeout(id));
}

// -------------------------
// Panel status helpers
// -------------------------
function setPill(el, text, cls){ // cls: "live"|"ok"|"warn"|"" (base)
  if (!el) return;
  el.className = "status-pill" + (cls ? ` ${cls}` : "");
  el.textContent = text;
}

const panelUpdatedAt = {
  transcript: 0,
  snapshot: 0,
  coach: 0,
};

function markUpdated(which){
  panelUpdatedAt[which] = Date.now();
}

// Run every 5s to refresh staleness (no UPDATED x ago labels)
setInterval(() => {
  const now = Date.now();

  // Snapshot stale threshold: 10 min
  const snapPill = document.getElementById("snap_state");
  const snapTime = document.getElementById("snap_time");
  if (snapPill && snapTime) {
    if (!panelUpdatedAt.snapshot) {
      snapPill.style.display = "none";
      snapTime.style.display = "none";
    } else {
      const snapAge = now - panelUpdatedAt.snapshot;
      snapPill.style.display = "inline-flex";
      if (snapAge > 10*60*1000) setPill(snapPill, "STALE", "warn");
      else setPill(snapPill, "READY", "ok");
    }
  }

  // Coach stale threshold: 5 min (no UPDATED x ago)
  const coachPill = document.getElementById("coach_state");
  if (coachPill) coachPill.style.display = "none";
}, 5000);

// -------------------------
// State
// -------------------------
let sessionId = null;
let recorder = null;
let audioStream = null;
let isRecording = false;
let recState = "idle"; // "idle" | "recording" | "paused"
let chosenMime = "";
let chosenExt = "webm";
let chunkStopTimeout = null;
let timerInterval = null;
let secondsElapsed = 0;
let micVizAudioCtx = null;
let micVizSource = null;
let micVizAnalyser = null;
let micVizData = null;
let micVizRaf = null;
let micVizLevel = 0;
let micVizPeakLevel = 0;
let micVizPeakAt = 0;
let micVizPalette = {
  active: "rgba(255,255,255,0.6)",
  idle: "rgba(255,255,255,0.2)",
};
let micFrameHistory = [];
let micClipBurst = 0;
let lastClipWarnAt = 0;
const MIC_FRAME_KEEP_MS = 120000;
const SILENCE_RMS_THRESHOLD = 0.012;
const CHUNK_SILENCE_RATIO_MAX = 0.7;
const CHUNK_MIN_VOICED_FRAMES = 4;
const CHUNK_RECENT_SPEECH_MS = 600;
const CLIP_PEAK_THRESHOLD = 0.98;
const CLIP_WARN_COOLDOWN_MS = 30000;
let snapshotDebounce = null;
let lastSnapshotHash = "";
let lastPatientSummaryHash = "";
let hasAiSummary = false;
let patientSummaryBusy = false;
let lastCoachHash = "";
const COACH_MIN_DELTA_CHARS = 600;
const COACH_MIN_DELTA_WORDS = 40;
const COACH_SMALL_DELTA_CHARS = 250;
const COACH_DEBOUNCE_MS = 25000;
let lastCoachRunAt = 0;
let coachPendingChars = 0;
let coachPendingWords = 0;
let emrBackgroundText = "";
let macros = [];
let editingMacroId = "";
const AUTH_TOKEN_KEY = "centaur_auth_token_v1";
let authToken = String(localStorage.getItem(AUTH_TOKEN_KEY) || "");
let authUser = null;
let profileCache = null;
let appBootstrapped = false;
let billingArchiveItems = [];
let billingArchiveCurrent = "";
let billingArchiveCurrentMeta = null;
let hasBilledCurrentPatient = false;
let wakeLockSentinel = null;
let noteLogItems = [];
let noteLogCurrentId = "";
let noteDraftActive = false;
let noteDraftKeyHandler = null;
let noteDraftTemplateId = "";
let noteDraftTemplateLabel = "";
let ambientEnabled = true;
let ambientController = null;

// Patient anchor (best-effort)
let patientName = "";
let patientPHN = "";
let patientAge = ""; // years as string, e.g. "27"

// -------------------------
// DOM refs
// -------------------------
const transcriptBox = document.getElementById("transcript_box");
const waveformBtn = document.getElementById("waveform_btn");
const timerEl = document.getElementById("recordTimer");
const recordBtn = document.getElementById("record_btn");
const recordBtnLabel = document.getElementById("record_btn_label");
const micLevelCanvas = document.getElementById("micLevelCanvas");
const newBtn    = document.getElementById("new_patient_btn");
const snapshotPanel = document.getElementById("snapshot_panel");
const coachPanel    = document.getElementById("coach_panel");

const chatLog   = document.querySelector(".chatlog");
const chatInput = document.getElementById("cqTextArea");
const sendBtn   = document.getElementById("cqSendBtn");
const soapBtn       = document.getElementById("soapBtn");
const referralBtn   = document.getElementById("referralBtn");
const rxBtn         = document.getElementById("rxBtn");

const cqChatInputWrap = document.getElementById("cqChatInputWrap");

// Billing UI refs (SIMPLIFIED)
const dailyBillingText = document.getElementById("dailyBillingText");
const billingModelSelect = document.getElementById("billingModelSelect");
const billingDateEl = document.getElementById("billingDate");
const billBtn = document.getElementById("billBtn");
const saveBillingBtn = document.getElementById("saveBillingBtn");
const printBillingBtn = document.getElementById("printBillingBtn");
const ambientBar = null;
const ambientStatusPill = null;
const ambientStatusText = null;
const ambientQueueCount = null;
const ambientConsentBtn = null;
const ambientPauseBtn = null;
const ambientStopBtn = null;
const ambientClearBtn = null;
const ambientSettingsBtn = null;

// Menu + Macro UI refs
const menuBtn = document.getElementById("menuBtn");
const menuPopover = document.getElementById("menuPopover");
const macroBuilderBtn = document.getElementById("macroBuilderBtn");
const macroSelect = document.getElementById("macroSelect");
const macroOverlay = document.getElementById("macroOverlay");
const macroPanel = document.getElementById("macroPanel");
const macroCloseBtn = document.getElementById("macroCloseBtn");
const macroAddBtn = document.getElementById("macroAddBtn");
const macroPickerSelect = document.getElementById("macroPickerSelect");
const aboutBtn = document.getElementById("aboutBtn");
const aboutOverlay = document.getElementById("aboutOverlay");
const aboutPanel = document.getElementById("aboutPanel");
const aboutCloseBtn = document.getElementById("aboutCloseBtn");
const feedbackBtn = document.getElementById("feedbackBtn");
const feedbackOverlay = document.getElementById("feedbackOverlay");
const feedbackPanel = document.getElementById("feedbackPanel");
const feedbackCloseBtn = document.getElementById("feedbackCloseBtn");
const feedbackEmail = document.getElementById("feedbackEmail");
const feedbackMessage = document.getElementById("feedbackMessage");
const feedbackStatus = document.getElementById("feedbackStatus");
const feedbackSendBtn = document.getElementById("feedbackSendBtn");
const feedbackCancelBtn = document.getElementById("feedbackCancelBtn");
const noteLogBtn = document.getElementById("noteLogBtn");
const noteLogOverlay = document.getElementById("noteLogOverlay");
const noteLogPanel = document.getElementById("noteLogPanel");
const noteLogCloseBtn = document.getElementById("noteLogCloseBtn");
const noteLogCloseBtn2 = document.getElementById("noteLogCloseBtn2");
const noteLogSearch = document.getElementById("noteLogSearch");
const noteLogList = document.getElementById("noteLogList");
const noteLogOutputs = document.getElementById("noteLogOutputs");
const noteLogInputs = document.getElementById("noteLogInputs");
const noteLogMeta = document.getElementById("noteLogMeta");
const noteLogStatus = document.getElementById("noteLogStatus");
const noteLogDeleteBtn = document.getElementById("noteLogDeleteBtn");
const noteLogTabOutputs = document.getElementById("noteLogTabOutputs");
const noteLogTabInputs = document.getElementById("noteLogTabInputs");
const noteLogTabMeta = document.getElementById("noteLogTabMeta");
const profileOverlay = document.getElementById("profileOverlay");
const profilePanel = document.getElementById("profilePanel");
const profileCloseBtn = document.getElementById("profileCloseBtn");
const profileSignatureName = document.getElementById("profileSignatureName");
const profileCpsa = document.getElementById("profileCpsa");
const profileDefaultFundingModel = document.getElementById("profileDefaultFundingModel");
const profileClinicName = document.getElementById("profileClinicName");
const profileClinicAddress = document.getElementById("profileClinicAddress");
const profileClinicPhone = document.getElementById("profileClinicPhone");
const profileClinicFax = document.getElementById("profileClinicFax");
const ambientModeToggle = null;
const profileStatus = document.getElementById("profileStatus");
const profileSaveBtn = document.getElementById("profileSaveBtn");
const profileCancelBtn = document.getElementById("profileCancelBtn");
const localKbBtn = document.getElementById("localKbBtn");
const kbOverlay = document.getElementById("kbOverlay");
const kbPanel = document.getElementById("kbPanel");
const kbCloseBtn = document.getElementById("kbCloseBtn");
const kbUrlInput = document.getElementById("kbUrlInput");
const kbStatus = document.getElementById("kbStatus");
const kbIndexBtn = document.getElementById("kbIndexBtn");
const kbRefreshBtn = document.getElementById("kbRefreshBtn");
const kbSiteList = document.getElementById("kbSiteList");
const kbSitesTab = document.getElementById("kbSitesTab");
const kbGuidelinesTab = document.getElementById("kbGuidelinesTab");
const kbSitesView = document.getElementById("kbSitesView");
const kbGuidelinesView = document.getElementById("kbGuidelinesView");
const kbGuidelineList = document.getElementById("kbGuidelineList");
const kbGuidelineStatus = document.getElementById("kbGuidelineStatus");
const kbGuidelineRefreshBtn = document.getElementById("kbGuidelineRefreshBtn");
const kbGuidelineOverlay = document.getElementById("kbGuidelineOverlay");
const kbGuidelinePanel = document.getElementById("kbGuidelinePanel");
const kbGuidelineCloseBtn = document.getElementById("kbGuidelineCloseBtn");
const kbGuidelineCloseBtn2 = document.getElementById("kbGuidelineCloseBtn2");
const kbGuidelineSourceLink = document.getElementById("kbGuidelineSourceLink");
const kbGuidelineFrame = document.getElementById("kbGuidelineFrame");
const kbGuidelineNodes = document.getElementById("kbGuidelineNodes");
const kbGuidelineEdges = document.getElementById("kbGuidelineEdges");
const kbGuidelineAddNode = document.getElementById("kbGuidelineAddNode");
const kbGuidelineAddEdge = document.getElementById("kbGuidelineAddEdge");
const kbGuidelineSaveBtn = document.getElementById("kbGuidelineSaveBtn");
const kbGuidelineReextractBtn = document.getElementById("kbGuidelineReextractBtn");
const kbGuidelineEditStatus = document.getElementById("kbGuidelineEditStatus");
const referralOverlay = document.getElementById("referralOverlay");
const referralPanel = document.getElementById("referralPanel");
const referralCloseBtn = document.getElementById("referralCloseBtn");
const referralCloseBtn2 = document.getElementById("referralCloseBtn2");
const referralStatus = document.getElementById("referralStatus");
const referralLetterText = document.getElementById("referralLetterText");
const referralMissing = document.getElementById("referralMissing");
const referralLoading = document.getElementById("referralLoading");
const referralCopyBtn = document.getElementById("referralCopyBtn");
const referralSpecialtyInput = document.getElementById("referralSpecialtyInput");
const referralGenerateBtn = document.getElementById("referralGenerateBtn");
const noteDraftOverlay = document.getElementById("noteDraftOverlay");
const noteDraftPanel = document.getElementById("noteDraftPanel");
const noteDraftTitle = document.getElementById("noteDraftTitle");
const noteDraftText = document.getElementById("noteDraftText");
const noteDraftStatus = document.getElementById("noteDraftStatus");
const noteDraftCopyBtn = document.getElementById("noteDraftCopyBtn");
const noteDraftCloseBtn = document.getElementById("noteDraftCloseBtn");
const noteDraftCloseBtn2 = document.getElementById("noteDraftCloseBtn2");
const noteDraftLoading = document.getElementById("noteDraftLoading");
const toastEl = document.getElementById("toast");

// Auth UI refs
const authOverlay = document.getElementById("authOverlay");
const authTabLogin = document.getElementById("authTabLogin");
const authTabSignup = document.getElementById("authTabSignup");
const authLoginForm = document.getElementById("authLoginForm");
const authSignupForm = document.getElementById("authSignupForm");
const authLoginUsername = document.getElementById("authLoginUsername");
const authLoginPassword = document.getElementById("authLoginPassword");
const authSignupUsername = document.getElementById("authSignupUsername");
const authSignupEmail = document.getElementById("authSignupEmail");
const authSignupPassword = document.getElementById("authSignupPassword");
const authError = document.getElementById("authError");

// Profile menu refs
const profileBtn = document.getElementById("profileBtn");
const profilePopover = document.getElementById("profilePopover");
const signOutBtn = document.getElementById("signOutBtn");
const reviewBillingBtn = document.getElementById("reviewBillingBtn");
const personalizationBtn = document.getElementById("personalizationBtn");
const coachReportBtn = document.getElementById("coachReportBtn");

// Clinical Query mode refs

// Billing archive refs
const billingArchiveOverlay = document.getElementById("billingArchiveOverlay");
const billingArchivePanel = document.getElementById("billingArchivePanel");
const billingArchiveCloseBtn = document.getElementById("billingArchiveCloseBtn");
const billingArchiveSelect = document.getElementById("billingArchiveSelect");
const billingArchiveRefreshBtn = document.getElementById("billingArchiveRefreshBtn");
const billingArchiveDeleteBtn = document.getElementById("billingArchiveDeleteBtn");
const billingArchiveText = document.getElementById("billingArchiveText");
const billingArchiveSaveBtn = document.getElementById("billingArchiveSaveBtn");
const billingArchivePrintBtn = document.getElementById("billingArchivePrintBtn");
const billingArchiveMeta = document.getElementById("billingArchiveMeta");
const macroEditBtn = document.getElementById("macroEditBtn");
const macroDeleteBtn = document.getElementById("macroDeleteBtn");
const macroNameInput = document.getElementById("macroNameInput");
const macroContentInput = document.getElementById("macroContentInput");
const macroSaveBtn = document.getElementById("macroSaveBtn");
const macroCancelBtn = document.getElementById("macroCancelBtn");
const macroStatus = document.getElementById("macroStatus");
const globalCopyBtn = document.getElementById("globalCopyBtn");
const themeBtn = document.getElementById("themeBtn");
const newPatientConfirmOverlay = document.getElementById("newPatientConfirmOverlay");
const newPatientConfirmPanel = document.getElementById("newPatientConfirmPanel");
const newPatientConfirmCancelBtn = document.getElementById("newPatientConfirmCancelBtn");
const newPatientConfirmProceedBtn = document.getElementById("newPatientConfirmProceedBtn");

// -------------------------
// Helpers
// -------------------------
function safeJsonStringify(obj) {
  try { return JSON.stringify(obj, null, 2); } catch { return String(obj); }
}

/* never let UI render [object Object] */
function asText(x) {
  if (x === null || x === undefined) return "";
  if (typeof x === "string") return x;
  if (typeof x === "number" || typeof x === "boolean") return String(x);
  return safeJsonStringify(x);
}

function uiError(where, err) {
  console.error(where, err);
  logChat("System", `${where}: ${err?.message || err}`);
}
window.addEventListener("error", (e) => {
  try { uiError("Unhandled error", e?.error || new Error(e?.message || "Unhandled error")); } catch {}
});
window.addEventListener("unhandledrejection", (e) => {
  try { uiError("Unhandled promise rejection", e?.reason || new Error("Unhandled promise rejection")); } catch {}
});

function setRecordingUI(active) {
  if (recordBtnLabel) recordBtnLabel.textContent = active ? "Pause" : "Record";
  if (recordBtn) {
    if (active) recordBtn.classList.remove("record-glow");
    else recordBtn.classList.add("record-glow");
  }
}
function formatTime(totalSeconds) {
  const m = String(Math.floor(totalSeconds / 60)).padStart(2, "0");
  const s = String(totalSeconds % 60).padStart(2, "0");
  return `${m}:${s}`;
}
function startTimer() {
  secondsElapsed = 0;
  if (timerEl) timerEl.textContent = "00:00";
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    secondsElapsed++;
    if (timerEl) timerEl.textContent = formatTime(secondsElapsed);
  }, 1000);
}
function stopTimer() {
  clearInterval(timerInterval);
}

function refreshMicVizPalette() {
  const styles = getComputedStyle(document.documentElement);
  const active = styles.getPropertyValue("--mic-level-active").trim();
  const idle = styles.getPropertyValue("--mic-level-idle").trim();
  micVizPalette = {
    active: active || "rgba(255,255,255,0.6)",
    idle: idle || "rgba(255,255,255,0.2)",
  };
}

async function startMicViz(stream) {
  if (!micLevelCanvas || !stream) return;
  micLevelCanvas.classList.add("active");
  const ctx = micLevelCanvas.getContext("2d");
  refreshMicVizPalette();
  if (!micVizAudioCtx) {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    micVizAudioCtx = new AudioCtx();
  }
  if (micVizAudioCtx.state === "suspended") {
    try { await micVizAudioCtx.resume(); } catch {}
  }
  try { micVizSource?.disconnect(); } catch {}
  micVizAnalyser = micVizAudioCtx.createAnalyser();
  micVizAnalyser.fftSize = 512;
  micVizData = new Uint8Array(micVizAnalyser.fftSize);
  micVizSource = micVizAudioCtx.createMediaStreamSource(stream);
  micVizSource.connect(micVizAnalyser);

  const draw = () => {
    micVizRaf = requestAnimationFrame(draw);
    if (!micVizAnalyser || !micVizData) return;
    micVizAnalyser.getByteTimeDomainData(micVizData);
    let sum = 0;
    let maxAbs = 0;
    for (let i = 0; i < micVizData.length; i++) {
      const v = (micVizData[i] - 128) / 128;
      maxAbs = Math.max(maxAbs, Math.abs(v));
      sum += v * v;
    }
    const rms = Math.sqrt(sum / micVizData.length);
    const clip = maxAbs >= CLIP_PEAK_THRESHOLD;
    const level = Math.max(0, Math.min(1, (rms - 0.02) * 4.5));
    micVizLevel = micVizLevel * 0.8 + level * 0.2;
    pushMicFrame(rms, clip);

    const width = micLevelCanvas.width;
    const height = micLevelCanvas.height;
    ctx.clearRect(0, 0, width, height);
    const dotCount = 12;
    const radius = Math.max(2, Math.min(3.2, height * 0.22));
    const gap = Math.max(4, Math.round(radius * 1.7));
    const totalWidth = dotCount * radius * 2 + (dotCount - 1) * gap;
    let x = (width - totalWidth) / 2 + radius;
    for (let i = 0; i < dotCount; i++) {
      const pos = i / (dotCount - 1);
      const dist = Math.abs(pos * 2 - 1);
      const centerWeight = Math.pow(1 - dist, 0.8);
      const intensity = micVizLevel * (0.35 + 0.65 * centerWeight);
      const alpha = Math.max(0.12, Math.min(0.6, 0.12 + intensity * 0.55));
      const color = micVizPalette.active.replace(/[\d\.]+\)$/, `${alpha})`);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, height / 2, radius, 0, Math.PI * 2);
      ctx.fill();
      x += radius * 2 + gap;
    }
  };
  draw();
}

function stopMicViz() {
  if (micVizRaf) cancelAnimationFrame(micVizRaf);
  micVizRaf = null;
  try { micVizSource?.disconnect(); } catch {}
  micVizSource = null;
  micVizAnalyser = null;
  micVizData = null;
  micVizLevel = 0;
  if (micLevelCanvas) {
    micLevelCanvas.classList.remove("active");
    const ctx = micLevelCanvas.getContext("2d");
    if (ctx) ctx.clearRect(0, 0, micLevelCanvas.width, micLevelCanvas.height);
  }
  resetMicAnalysis();
}

function resetMicAnalysis() {
  micFrameHistory = [];
  micClipBurst = 0;
  lastClipWarnAt = 0;
  micVizPeakLevel = 0;
  micVizPeakAt = 0;
}

function pushMicFrame(rms, clip) {
  const now = performance.now();
  micFrameHistory.push({ t: now, rms, clip });
  const cutoff = now - MIC_FRAME_KEEP_MS;
  while (micFrameHistory.length && micFrameHistory[0].t < cutoff) {
    micFrameHistory.shift();
  }
  if (clip) {
    micClipBurst += 1;
  } else {
    micClipBurst = Math.max(0, micClipBurst - 1);
  }
  if (clip && micClipBurst >= 5 && (now - lastClipWarnAt) > CLIP_WARN_COOLDOWN_MS) {
    lastClipWarnAt = now;
    showToast("Mic is clipping. Reduce input level or move mic farther away.", "warn");
  }
}

function analyzeChunkAudioStats(startMs, endMs) {
  if (!micFrameHistory.length) return null;
  const frames = micFrameHistory.filter(f => f.t >= startMs && f.t <= endMs);
  if (!frames.length) return null;
  let silenceFrames = 0;
  let voicedFrames = 0;
  let maxRms = 0;
  let clipped = false;
  for (const f of frames) {
    maxRms = Math.max(maxRms, f.rms);
    if (f.rms < SILENCE_RMS_THRESHOLD) silenceFrames += 1;
    else voicedFrames += 1;
    if (f.clip) clipped = true;
  }
  const total = frames.length;
  const silenceRatio = total ? (silenceFrames / total) : 1;
  const recentSpeech = frames.some(f => f.rms >= SILENCE_RMS_THRESHOLD && f.t >= (endMs - CHUNK_RECENT_SPEECH_MS));
  return {
    totalFrames: total,
    silenceRatio,
    voicedFrames,
    recentSpeech,
    maxRms,
    clipped,
  };
}

function shouldDropChunk(stats) {
  if (!stats) return false;
  if (stats.totalFrames < 6) return false;
  if (stats.voicedFrames < CHUNK_MIN_VOICED_FRAMES && !stats.recentSpeech) return true;
  if (stats.silenceRatio >= CHUNK_SILENCE_RATIO_MAX && !stats.recentSpeech) return true;
  return false;
}
function escapeHtml(s) {
  return (s || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;");
}
function stripPairedMarkdownEmphasis(text) {
  const s0 = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  let s = s0
    .replace(/\*\*([^\n*]+)\*\*/g, "$1")
    .replace(/__([^\n_]+)__/g, "$1");
  s = s.replace(/[ \t]+\n/g, "\n");
  s = s.replace(/\n{3,}/g, "\n\n");
  return s;
}
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function flashButton(btn){
  if (!btn) return;
  btn.classList.add("btn-flash");
  setTimeout(() => btn.classList.remove("btn-flash"), 180);
}
async function runWithButtonBusy(btn, busyText, fn){
  if (!btn) return await fn();
  const wasDisabled = btn.disabled;
  const originalText = btn.textContent;
  flashButton(btn);
  btn.disabled = true;
  btn.classList.add("busy");
  if (busyText) btn.textContent = busyText;
  try {
    return await fn();
  } finally {
    btn.textContent = originalText;
    btn.disabled = wasDisabled;
    btn.classList.remove("busy");
  }
}
async function runWithButtonFeedback(btn, busyText, doneText, fn){
  if (!btn) return await fn();
  const wasDisabled = btn.disabled;
  const originalText = btn.textContent;
  flashButton(btn);
  btn.disabled = true;
  btn.classList.add("busy");
  if (busyText) btn.textContent = busyText;
  try {
    const out = await fn();
    btn.textContent = doneText || originalText;
    await sleep(450);
    return out;
  } finally {
    btn.textContent = originalText;
    btn.disabled = wasDisabled;
    btn.classList.remove("busy");
  }
}

function plainToHtml(plain) {
  const esc = (s) => String(s || "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;");
  const text = String(plain || "")
    .replace(/\r\n/g, "\n")
    .replace(/\r/g, "\n");
  const blocks = text.split(/\n{2,}/g).map(b => b.trim()).filter(Boolean);
  const htmlBlocks = blocks.map(block => {
    const lines = block.split("\n");
    const isBulletBlock = lines.length > 0 && lines.every(l => l.trim().startsWith("- "));
    if (isBulletBlock) {
      const items = lines.map(l => esc(l.trim().slice(2)));
      return `<ul>${items.map(it => `<li>${it}</li>`).join("")}</ul>`;
    }
    if (lines.length === 1 && /:\s*$/.test(lines[0].trim())) {
      return `<p><strong>${esc(lines[0].trim())}</strong></p>`;
    }
    return `<p>${esc(block).replaceAll("\n", "<br>")}</p>`;
  });
  return `<!doctype html><html><body>${htmlBlocks.join("")}</body></html>`;
}
async function copyRichText(plainText) {
  const plain = String(plainText || "");
  const html = plainToHtml(plain);
  try {
    if (navigator.clipboard?.write && window.ClipboardItem) {
      const item = new ClipboardItem({
        "text/plain": new Blob([plain], { type: "text/plain" }),
        "text/html":  new Blob([html],  { type: "text/html"  }),
      });
      await navigator.clipboard.write([item]);
      return true;
    }
  } catch {}

  try {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(plain);
      return true;
    }
  } catch {}

  const ta = document.createElement("textarea");
  ta.value = plain;
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "0";
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  let ok = false;
  try { ok = document.execCommand("copy"); } catch {}
  document.body.removeChild(ta);
  return ok;
}

async function copyToClipboardWithStatus(label, text) {
  const ok = await copyRichText(text);
  if (ok) {
    logChat("System", `${label} copied.`);
    return true;
  }
  logChat("System", `${label} copy blocked. Click anywhere to finish copy.`);
  scheduleClipboardRetry(label, text);
  return false;
}

function scheduleClipboardRetry(label, text) {
  const payload = { label, text };
  const handler = async () => {
    const ok = await copyRichText(payload.text);
    if (ok) logChat("System", `${payload.label} copied.`);
    else logChat("System", `${payload.label} copy failed. Click Copy to copy manually.`);
  };
  document.addEventListener("click", handler, { once: true, capture: true });
  document.addEventListener("keydown", handler, { once: true, capture: true });
}

let lastAssistantPlainText = "";

function stripCodeFences(s){
  s = (s || "").trim();
  if (s.startsWith("```")) {
    s = s.replace(/^```[a-zA-Z0-9]*\s*/,"").replace(/\s*```$/,"");
  }
  return s.trim();
}

function safeSubsetFormat(text) {
  const raw = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const headingNames = [
    "Issues","Subjective","Safety / red flags","Safety / Red flags","Safety / Red Flags",
    "Objective","Assessment","Plan","Procedure","Med Review","Preventive Health Care Review",
  ];
  const isHeadingLine = (lineTrim) => {
    let t = lineTrim;
    const mm = t.match(/^\*\*(.+?)\*\*\s*:?\s*$/);
    if (mm && mm[1]) t = mm[1].trim();
    t = t.replace(/:\s*$/, "").trim();
    t = t.replace(/\s*\/\s*/g, " / ");
    return headingNames.some(h => h.toLowerCase() === t.toLowerCase());
  };
  const normalizeHeading = (lineTrim) => {
    let t = lineTrim;
    const mm = lineTrim.match(/^\*\*(.+?)\*\*\s*:?\s*$/);
    if (mm && mm[1]) t = mm[1].trim();
    t = t.replace(/:\s*$/, "").trim();
    t = t.replace(/\s*\/\s*/g, " / ");
    return t;
  };
  const lines = raw.split("\n");
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    if (isHeadingLine(trimmed)) {
      const heading = normalizeHeading(trimmed);
      if (out.length > 0 && out[out.length - 1] !== "") out.push("");
      out.push(heading);
      continue;
    }
    out.push(line.replace(/[ \t]+$/g, ""));
  }
  let s = out.join("\n").replace(/\n{3,}/g, "\n\n");
  s = escapeHtml(s);
  const headingRe = /^(Issues|Subjective|Safety\s*\/\s*Red\s*Flags|Safety\s*\/\s*Red\s*flags|Objective|Assessment|Plan|Procedure|Med Review|Preventive Health Care Review)\s*$/gmi;
  s = s.replace(headingRe, "<strong>$1</strong>");
  s = s.replace(/\*\*([^\n*]+)\*\*/g, "$1").replace(/__([^\n_]+)__/g, "$1");
  s = s.replace(/[ \t]+\n/g, "\n");
  return s;
}

// -------------------------
// Templates
// -------------------------
const MACROS_CACHE_KEY = "centaur_macros_cache_v1";
const MACRO_SELECTED_KEY = "centaur_macro_selected_v1";
const FEEDBACK_EMAIL_KEY = "centaur_feedback_email_v1";

function normalizeMacroRecord(m) {
  const id = String(m?.id || "").trim();
  const name = String(m?.name || "").trim();
  const content = String(m?.content || "").trim();
  const updatedRaw = m?.updated_at_utc || m?.updatedAt || m?.updated_at || "";
  const updatedAt = updatedRaw ? Date.parse(updatedRaw) || Date.now() : (Number(m?.updatedAt) || Date.now());
  const locked = Boolean(m?.locked);
  if (!id || !name || !content) return null;
  return { id, name, content, updatedAt, locked };
}

function isMacroVisible(macro) {
  return String(macro?.name || "").trim().toLowerCase() !== "soap";
}

function loadMacrosFromCache() {
  try {
    const raw = localStorage.getItem(MACROS_CACHE_KEY);
    const parsed = raw ? JSON.parse(raw) : [];
    if (!Array.isArray(parsed)) { macros = []; return; }
    macros = parsed.map(normalizeMacroRecord).filter(Boolean);
    macros.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
  } catch {
    macros = [];
  }
}

function saveMacrosToCache() {
  try { localStorage.setItem(MACROS_CACHE_KEY, JSON.stringify(macros)); } catch {}
}

async function loadMacrosFromServer() {
  try {
    const data = await apiGet("/macros");
    const list = Array.isArray(data?.macros) ? data.macros : [];
    macros = list.map(normalizeMacroRecord).filter(Boolean);
    macros.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
    saveMacrosToCache();
  } catch {
    loadMacrosFromCache();
  }
}

function getSelectedMacroId() {
  return String(localStorage.getItem(MACRO_SELECTED_KEY) || "");
}

function setSelectedMacroId(id) {
  const visible = macros.filter(isMacroVisible);
  const valid = visible.some(m => m.id === id) ? id : "";
  try { localStorage.setItem(MACRO_SELECTED_KEY, valid); } catch {}
  if (macroSelect) macroSelect.value = valid;
  return valid;
}

function getSelectedMacro() {
  const id = getSelectedMacroId();
  return macros.find(m => m.id === id) || null;
}

function refreshMacroDropdown() {
  if (!macroSelect) return;
  const selectedId = getSelectedMacroId();
  macroSelect.innerHTML = "";
  const optNone = document.createElement("option");
  optNone.value = "";
  optNone.textContent = "Templates";
  macroSelect.appendChild(optNone);
  for (const m of macros.filter(isMacroVisible)) {
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = m.name;
    macroSelect.appendChild(opt);
  }
  const valid = macros.filter(isMacroVisible).some(m => m.id === selectedId) ? selectedId : "";
  macroSelect.value = valid;
  if (selectedId !== valid) {
    try { localStorage.setItem(MACRO_SELECTED_KEY, valid); } catch {}
  }
}

function setMacroStatus(message, isError=false) {
  if (!macroStatus) return;
  macroStatus.textContent = message || "";
  macroStatus.className = "macro-status" + (isError ? " error" : "");
}

function setEditorValues(macro) {
  if (!macroNameInput || !macroContentInput) return;
  macroNameInput.value = macro?.name || "";
  macroContentInput.value = macro?.content || "";
}

function getMacroByName(name) {
  const target = String(name || "").trim().toLowerCase();
  if (!target) return null;
  return macros.find(m => String(m?.name || "").trim().toLowerCase() === target) || null;
}

function expandMacroTemplate(template, vars) {
  let out = String(template || "");
  const rep = vars || {};
  for (const key of Object.keys(rep)) {
    const val = (rep[key] == null || String(rep[key]).trim() === "") ? "[none]" : String(rep[key]);
    const re = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}|\\{\\s*${key}\\s*\\}`, "gi");
    out = out.replace(re, val);
  }
  return out;
}

function refreshMacroPicker(selectedId="") {
  if (!macroPickerSelect) return;
  const current = selectedId || macroPickerSelect.value || "";
  macroPickerSelect.innerHTML = "";
  const optNone = document.createElement("option");
  optNone.value = "";
  optNone.textContent = "Select template";
  macroPickerSelect.appendChild(optNone);
  for (const m of macros.filter(isMacroVisible)) {
    const opt = document.createElement("option");
    opt.value = m.id;
    opt.textContent = m.name;
    macroPickerSelect.appendChild(opt);
  }
  macroPickerSelect.value = macros.filter(isMacroVisible).some(m => m.id === current) ? current : "";
  const selected = macros.find(m => m.id === macroPickerSelect.value);
  if (macroDeleteBtn) {
    const locked = Boolean(selected?.locked);
    macroDeleteBtn.disabled = locked;
    macroDeleteBtn.textContent = locked ? "Locked" : "Delete";
  }
}

function startNewMacro() {
  editingMacroId = "";
  setEditorValues(null);
  setMacroStatus("");
  refreshMacroPicker("");
}

async function saveMacroFromEditor() {
  const name = String(macroNameInput?.value || "").trim();
  const content = String(macroContentInput?.value || "").trim();
  if (!name || !content) {
    setMacroStatus("Name and content are required.", true);
    return;
  }
  setMacroStatus("Savingâ€¦");
  try {
    const payload = { name, content };
    let saved = null;
    if (editingMacroId) {
      const resp = await apiPut(`/macros/${editingMacroId}`, payload);
      saved = resp?.macro || resp;
    } else {
      const resp = await apiPost(`/macros`, payload);
      saved = resp?.macro || resp;
    }
    const normalized = normalizeMacroRecord(saved);
    if (!normalized) throw new Error("Invalid template response");
    const idx = macros.findIndex(m => m.id === normalized.id);
    if (idx >= 0) macros[idx] = normalized;
    else macros.unshift(normalized);
    editingMacroId = normalized.id;
    macros.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
  } catch (err) {
    setMacroStatus(`Save failed: ${err?.message || err}`, true);
    return;
  }
  saveMacrosToCache();
  refreshMacroDropdown();
  setSelectedMacroId(editingMacroId);
  refreshMacroPicker(editingMacroId);
  setMacroStatus("Saved.");
}

function cancelMacroEdit() {
  if (editingMacroId) {
    const current = macros.find(m => m.id === editingMacroId);
    if (current) setEditorValues(current);
    setMacroStatus("");
  } else {
    setEditorValues(null);
    setMacroStatus("");
  }
}

function openMacroPanel() {
  if (!macroPanel || !macroOverlay) return;
  macroOverlay.style.display = "block";
  macroPanel.style.display = "flex";
  document.body.style.overflow = "hidden";
  refreshMacroPicker(getSelectedMacroId());
}

function closeMacroPanel() {
  if (!macroPanel || !macroOverlay) return;
  macroOverlay.style.display = "none";
  macroPanel.style.display = "none";
  document.body.style.overflow = "";
  setMacroStatus("");
}

function editMacroFromPicker() {
  const id = String(macroPickerSelect?.value || "").trim();
  if (!id) {
    setMacroStatus("Select a template to edit.", true);
    return;
  }
  const target = macros.find(m => m.id === id);
  if (!target) {
    setMacroStatus("Template not found.", true);
    return;
  }
  editingMacroId = id;
  setEditorValues(target);
  setMacroStatus("");
}

async function deleteMacroFromPicker() {
  const id = String(macroPickerSelect?.value || "").trim();
  if (!id) {
    setMacroStatus("Select a template to delete.", true);
    return;
  }
  const target = macros.find(m => m.id === id);
  if (!target) {
    setMacroStatus("Template not found.", true);
    return;
  }
  if (target.locked) {
    setMacroStatus("This template is locked and cannot be deleted.", true);
    return;
  }
  const ok = window.confirm(`Delete template "${target.name}"?`);
  if (!ok) return;
  setMacroStatus("Deletingâ€¦");
  try {
    await apiDelete(`/macros/${id}`);
  } catch (err) {
    setMacroStatus(`Delete failed: ${err?.message || err}`, true);
    return;
  }
  macros = macros.filter(m => m.id !== id);
  saveMacrosToCache();
  if (editingMacroId === id) {
    editingMacroId = "";
    setEditorValues(null);
  }
  refreshMacroDropdown();
  refreshMacroPicker("");
  setSelectedMacroId(getSelectedMacroId());
  setMacroStatus("Deleted.");
}

async function initMacros() {
  await loadMacrosFromServer();
  refreshMacroDropdown();
  refreshMacroPicker(getSelectedMacroId());
  cancelMacroEdit();
}

function closeMenuPopover() {
  if (menuPopover) menuPopover.style.display = "none";
}

function toggleMenuPopover() {
  if (!menuPopover) return;
  closeProfilePopover();
  const open = menuPopover.style.display !== "none";
  menuPopover.style.display = open ? "none" : "block";
}

function closeProfilePopover() {
  if (profilePopover) profilePopover.style.display = "none";
}

function toggleProfilePopover() {
  if (!profilePopover) return;
  closeMenuPopover();
  const open = profilePopover.style.display !== "none";
  profilePopover.style.display = open ? "none" : "block";
}

function openAboutPanel() {
  if (!aboutPanel || !aboutOverlay) return;
  aboutOverlay.style.display = "block";
  aboutPanel.style.display = "flex";
}

function closeAboutPanel() {
  if (!aboutPanel || !aboutOverlay) return;
  aboutOverlay.style.display = "none";
  aboutPanel.style.display = "none";
}

let toastTimer = null;
function showToast(message, kind="ok") {
  if (!toastEl) return;
  toastEl.textContent = message || "";
  toastEl.className = `toast ${kind}`;
  toastEl.style.display = "block";
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => {
    toastEl.style.display = "none";
  }, 2200);
}

function openFeedbackPanel() {
  if (!feedbackPanel || !feedbackOverlay) return;
  const stored = localStorage.getItem(FEEDBACK_EMAIL_KEY) || "";
  if (feedbackEmail && !feedbackEmail.value) {
    if (stored) feedbackEmail.value = stored;
    else if (authUser?.email) feedbackEmail.value = authUser.email;
  }
  setFeedbackStatus("");
  feedbackOverlay.style.display = "block";
  feedbackPanel.style.display = "flex";
}

function closeFeedbackPanel() {
  if (!feedbackPanel || !feedbackOverlay) return;
  feedbackOverlay.style.display = "none";
  feedbackPanel.style.display = "none";
}

function openNoteLogPanel() {
  if (!noteLogPanel || !noteLogOverlay) return;
  noteLogOverlay.style.display = "block";
  noteLogPanel.style.display = "flex";
  setNoteLogStatus("");
  setNoteLogTab("outputs");
  loadNoteLogList();
}

function closeNoteLogPanel() {
  if (!noteLogPanel || !noteLogOverlay) return;
  noteLogOverlay.style.display = "none";
  noteLogPanel.style.display = "none";
}

function setNoteLogStatus(message, isError=false) {
  if (!noteLogStatus) return;
  noteLogStatus.textContent = message || "";
  noteLogStatus.className = "macro-status" + (isError ? " error" : "");
}

function setNoteLogTab(tab) {
  if (!noteLogOutputs || !noteLogInputs || !noteLogMeta) return;
  noteLogOutputs.style.display = tab === "outputs" ? "block" : "none";
  noteLogInputs.style.display = tab === "inputs" ? "block" : "none";
  noteLogMeta.style.display = tab === "meta" ? "block" : "none";
  if (noteLogTabOutputs) noteLogTabOutputs.classList.toggle("active", tab === "outputs");
  if (noteLogTabInputs) noteLogTabInputs.classList.toggle("active", tab === "inputs");
  if (noteLogTabMeta) noteLogTabMeta.classList.toggle("active", tab === "meta");
}

function formatNoteLogTimestamp(iso) {
  if (!iso) return "";
  try {
    return new Date(iso).toLocaleString();
  } catch {
    return iso;
  }
}

function renderNoteLogList(items) {
  if (!noteLogList) return;
  noteLogList.innerHTML = "";
  if (!items.length) {
    const empty = document.createElement("div");
    empty.className = "note-log-item-sub";
    empty.textContent = "No note logs found.";
    noteLogList.appendChild(empty);
    return;
  }
  for (const item of items) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "note-log-item";
    if (noteLogCurrentId && item.id === noteLogCurrentId) {
      btn.classList.add("active");
    }
    const complaint = item.chief_complaint || "Visit";
    const title = `${item.patient_name || "Unknown"} â€” ${complaint} â€” ${formatNoteLogTimestamp(item.created_at_utc)}`;
    const titleEl = document.createElement("div");
    titleEl.className = "note-log-item-title";
    titleEl.textContent = title;
    const sub = document.createElement("div");
    sub.className = "note-log-item-sub";
    const types = Array.isArray(item.module_types) ? item.module_types.join(", ") : "";
    sub.textContent = types ? `Modules: ${types}` : "Modules: â€”";
    btn.appendChild(titleEl);
    btn.appendChild(sub);
    btn.addEventListener("click", async () => {
      await loadNoteLogDetail(item.id);
    });
    noteLogList.appendChild(btn);
  }
}

function filterNoteLogItems(query) {
  const q = (query || "").trim().toLowerCase();
  if (!q) return noteLogItems.slice();
  return noteLogItems.filter((item) => {
    const name = (item.patient_name || "").toLowerCase();
    const complaint = (item.chief_complaint || "").toLowerCase();
    return name.includes(q) || complaint.includes(q);
  });
}

async function loadNoteLogList() {
  try {
    const data = await apiGet("/note_log?limit=50&offset=0");
    noteLogItems = Array.isArray(data?.items) ? data.items : [];
    renderNoteLogList(filterNoteLogItems(noteLogSearch?.value || ""));
    if (noteLogItems.length) {
      const firstId = noteLogCurrentId || noteLogItems[0].id;
      await loadNoteLogDetail(firstId);
    } else {
      noteLogCurrentId = "";
      if (noteLogOutputs) noteLogOutputs.textContent = "No outputs stored.";
      if (noteLogInputs) noteLogInputs.textContent = "No inputs stored.";
      if (noteLogMeta) noteLogMeta.textContent = "No metadata.";
    }
    setNoteLogStatus("");
  } catch (err) {
    setNoteLogStatus(err?.message || "Failed to load note logs.", true);
  }
}

function formatNoteLogOutputs(outputs) {
  const parts = [];
  if (outputs?.soap_note) parts.push(`SOAP\n${outputs.soap_note}`);
  if (outputs?.referral_letter) parts.push(`Referral\n${outputs.referral_letter}`);
  if (outputs?.ddx_output) parts.push(`DDx\n${outputs.ddx_output}`);
  if (outputs?.billing_text) parts.push(`Billing\n${outputs.billing_text}`);
  return parts.join("\n\n").trim() || "No outputs stored.";
}

function formatNoteLogInputs(inputs) {
  const parts = [];
  if (inputs?.transcript) parts.push(`Transcript\n${inputs.transcript}`);
  if (inputs?.clinical_background) parts.push(`Clinical background\n${inputs.clinical_background}`);
  if (inputs?.netcare_background) parts.push(`Netcare background\n${inputs.netcare_background}`);
  if (inputs?.clinical_query_log) parts.push(`Clinical query log\n${inputs.clinical_query_log}`);
  if (inputs?.derived_context) {
    parts.push(`Derived context\n${safeJsonStringify(inputs.derived_context)}`);
  }
  return parts.join("\n\n").trim() || "No inputs stored.";
}

function formatNoteLogMeta(meta) {
  const lines = [];
  if (meta?.user) lines.push(`User: ${meta.user}`);
  if (meta?.session_id) lines.push(`Session: ${meta.session_id}`);
  if (meta?.patient_name) lines.push(`Patient: ${meta.patient_name}`);
  if (meta?.patient_id) lines.push(`Patient ID: ${meta.patient_id}`);
  if (meta?.chief_complaint) lines.push(`Chief complaint: ${meta.chief_complaint}`);
  return lines.join("\n") || "No metadata.";
}

function applyNoteLogSnapshot(entry) {
  if (!entry) return;
  const inputs = entry.inputs || {};
  const outputs = entry.outputs || {};
  if (transcriptBox && typeof inputs.transcript === "string") {
    transcriptBox.value = inputs.transcript;
  }
  if (snapshotPanel) {
    snapshotPanel.textContent = inputs.clinical_background || inputs.netcare_background || "";
  }
  if (coachPanel) {
    coachPanel.textContent = inputs.derived_context ? safeJsonStringify(inputs.derived_context) : "";
  }
  if (dailyBillingText && typeof outputs.billing_text === "string") {
    dailyBillingText.value = outputs.billing_text;
  }
  if (referralLetterText) {
    referralLetterText.innerHTML = referralTextToHtml(outputs.referral_letter || "");
  }
  if (chatLog) {
    const sections = [];
    if (outputs.soap_note) {
      sections.push(`<div class="note-log-load-section"><strong>SOAP note</strong><pre>${escapeHtml(outputs.soap_note)}</pre></div>`);
    }
    if (outputs.ddx_output) {
      sections.push(`<div class="note-log-load-section"><strong>DDx</strong><pre>${escapeHtml(outputs.ddx_output)}</pre></div>`);
    }
    if (outputs.billing_text) {
      sections.push(`<div class="note-log-load-section"><strong>Billing</strong><pre>${escapeHtml(outputs.billing_text)}</pre></div>`);
    }
    chatLog.innerHTML = sections.length ? sections.join("") : `<div class="note-log-load-section">No saved outputs.</div>`;
  }
}

async function loadNoteLogDetail(entryId) {
  if (!entryId) return;
  noteLogCurrentId = entryId;
  try {
    const data = await apiGet(`/note_log/${encodeURIComponent(entryId)}`);
    const entry = data?.entry || {};
    if (noteLogOutputs) noteLogOutputs.textContent = formatNoteLogOutputs(entry.outputs || {});
    if (noteLogInputs) noteLogInputs.textContent = formatNoteLogInputs(entry.inputs || {});
    if (noteLogMeta) noteLogMeta.textContent = formatNoteLogMeta(entry.metadata || {});
    renderNoteLogList(filterNoteLogItems(noteLogSearch?.value || ""));
    setNoteLogStatus("");
    applyNoteLogSnapshot(entry);
  } catch (err) {
    setNoteLogStatus(err?.message || "Failed to load entry.", true);
  }
}

async function deleteNoteLogEntry() {
  if (!noteLogCurrentId) return;
  try {
    await apiDelete(`/note_log/${encodeURIComponent(noteLogCurrentId)}`);
    noteLogCurrentId = "";
    await loadNoteLogList();
  } catch (err) {
    setNoteLogStatus(err?.message || "Delete failed.", true);
  }
}

async function maybeCreateNoteLogSnapshot() {
  if (!authUser?.is_admin) return;
  if (!sessionId) return;
  if (!hasCurrentPatientData()) return;
  try {
    await apiPost("/note_log", { session_id: sessionId });
  } catch (err) {
    console.warn("Note log snapshot failed:", err);
  }
}

function setAdminUIVisibility() {
  const isAdmin = !!authUser?.is_admin;
  if (localKbBtn) localKbBtn.style.display = isAdmin ? "block" : "none";
  if (noteLogBtn) noteLogBtn.style.display = isAdmin ? "block" : "none";
}

function openKbPanel() {
  if (!kbPanel || !kbOverlay) return;
  kbOverlay.style.display = "block";
  kbPanel.style.display = "flex";
  setKbStatus("");
  setKbTab("sites");
}

function closeKbPanel() {
  if (!kbPanel || !kbOverlay) return;
  kbOverlay.style.display = "none";
  kbPanel.style.display = "none";
}

function setKbStatus(message, isError=false) {
  if (!kbStatus) return;
  kbStatus.textContent = message || "";
  kbStatus.className = "macro-status" + (isError ? " error" : "");
}

function setKbTab(tab) {
  const showSites = tab === "sites";
  if (kbSitesView) kbSitesView.style.display = showSites ? "block" : "none";
  if (kbGuidelinesView) kbGuidelinesView.style.display = showSites ? "none" : "block";
  if (kbSitesTab) kbSitesTab.classList.toggle("active", showSites);
  if (kbGuidelinesTab) kbGuidelinesTab.classList.toggle("active", !showSites);
  if (showSites) {
    loadKbSites();
  } else {
    loadKbGuidelines();
  }
}

function renderKbSites(sites) {
  if (!kbSiteList) return;
  kbSiteList.innerHTML = "";
  if (!Array.isArray(sites) || sites.length === 0) {
    const empty = document.createElement("div");
    empty.className = "kb-site-item";
    empty.textContent = "No indexed sites yet.";
    kbSiteList.appendChild(empty);
    return;
  }
  for (const site of sites) {
    const wrap = document.createElement("div");
    wrap.className = "kb-site-item";
    const url = String(site.url || "");
    const updated = String(site.last_indexed_utc || "").replace("T", " ").replace("Z", "");
    const status = String(site.last_status || "");
    const err = String(site.last_error || "");
    const title = document.createElement("div");
    title.textContent = url;
    const meta = document.createElement("div");
    meta.className = "kb-site-meta";
    meta.textContent = `Last indexed: ${updated || "â€”"}${status ? ` | ${status}` : ""}${err ? ` | ${err}` : ""}`;
    wrap.appendChild(title);
    wrap.appendChild(meta);
    kbSiteList.appendChild(wrap);
  }
}

function setKbGuidelineStatus(message, isError=false) {
  if (!kbGuidelineStatus) return;
  kbGuidelineStatus.textContent = message || "";
  kbGuidelineStatus.className = "macro-status" + (isError ? " error" : "");
}

function renderKbGuidelines(items) {
  if (!kbGuidelineList) return;
  kbGuidelineList.innerHTML = "";
  if (!Array.isArray(items) || items.length === 0) {
    const empty = document.createElement("div");
    empty.className = "kb-site-item";
    empty.textContent = "No guidelines extracted yet.";
    kbGuidelineList.appendChild(empty);
    return;
  }
  for (const item of items) {
    const wrap = document.createElement("div");
    wrap.className = "kb-site-item";
    const title = document.createElement("div");
    title.textContent = item.title || item.source_url || item.guideline_id;
    const meta = document.createElement("div");
    meta.className = "kb-site-meta";
    const conf = (item.confidence || 0).toFixed(2);
    const updated = (item.updated_at_utc || "").replace("T", " ").replace("Z", "");
    meta.textContent = `Jurisdiction: ${item.jurisdiction || "â€”"} | Version: ${item.version_date || "â€”"} | Confidence: ${conf} | Updated: ${updated || "â€”"}`;
    const actions = document.createElement("div");
    actions.className = "macro-editor-actions";
    const viewBtn = document.createElement("button");
    viewBtn.type = "button";
    viewBtn.textContent = "View / QA";
    viewBtn.addEventListener("click", () => openKbGuidelineQA(item.guideline_id));
    actions.appendChild(viewBtn);
    wrap.appendChild(title);
    wrap.appendChild(meta);
    wrap.appendChild(actions);
    kbGuidelineList.appendChild(wrap);
  }
}

async function loadKbGuidelines() {
  if (!kbGuidelineList) return;
  try {
    const data = await apiGet("/admin/local_kb/guidelines");
    renderKbGuidelines(data?.guidelines || []);
  } catch (err) {
    renderKbGuidelines([]);
    setKbGuidelineStatus(err?.message || "Failed to load guidelines.", true);
  }
}

async function loadKbSites() {
  if (!kbSiteList) return;
  try {
    const data = await apiGet("/admin/local_kb/sites");
    renderKbSites(data?.sites || []);
  } catch (err) {
    renderKbSites([]);
    setKbStatus(err?.message || "Failed to load sites.", true);
  }
}

async function indexKbSite() {
  const url = String(kbUrlInput?.value || "").trim();
  if (!url) {
    setKbStatus("Enter a URL to index.", true);
    return;
  }
  setKbStatus("Indexingâ€¦");
  try {
    const data = await apiPost("/admin/local_kb/index", { url });
    const site = data?.site || {};
    const pages = site.pages_indexed ? ` (${site.pages_indexed} pages)` : "";
    setKbStatus(`Indexed ${site.url || url}${pages}.`);
    if (kbUrlInput) kbUrlInput.value = "";
    await loadKbSites();
  } catch (err) {
    const msg = err?.message || "Indexing failed.";
    setKbStatus(msg, true);
  }
}

let kbGuidelineBaseGraph = null;
let kbGuidelineDraftGraph = null;
let kbGuidelineCurrentId = "";

function openKbGuidelinePanel() {
  if (!kbGuidelinePanel || !kbGuidelineOverlay) return;
  kbGuidelineOverlay.style.display = "block";
  kbGuidelinePanel.style.display = "flex";
}

function closeKbGuidelinePanel() {
  if (!kbGuidelinePanel || !kbGuidelineOverlay) return;
  kbGuidelineOverlay.style.display = "none";
  kbGuidelinePanel.style.display = "none";
}

function setKbGuidelineEditStatus(message, isError=false) {
  if (!kbGuidelineEditStatus) return;
  kbGuidelineEditStatus.textContent = message || "";
  kbGuidelineEditStatus.className = "macro-status" + (isError ? " error" : "");
}

function renderGuidelineNodes(nodes) {
  if (!kbGuidelineNodes) return;
  kbGuidelineNodes.innerHTML = "";
  for (const node of nodes) {
    const row = document.createElement("div");
    row.className = "kb-editor-row";
    row.dataset.nodeId = node.id;
    const label = document.createElement("input");
    label.value = node.label || "";
    label.placeholder = "Node label";
    const type = document.createElement("select");
    for (const t of ["entry", "decision", "action", "investigation", "referral", "note", "exit"]) {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      type.appendChild(opt);
    }
    type.value = node.type || "note";
    const actions = document.createElement("textarea");
    actions.placeholder = "Actions (one per line)";
    actions.value = (node.actions || []).join("\\n");
    row.appendChild(label);
    row.appendChild(type);
    row.appendChild(actions);
    kbGuidelineNodes.appendChild(row);
  }
}

function renderGuidelineEdges(edges, nodes) {
  if (!kbGuidelineEdges) return;
  kbGuidelineEdges.innerHTML = "";
  const nodeIds = nodes.map(n => n.id);
  for (const edge of edges) {
    const row = document.createElement("div");
    row.className = "kb-editor-row";
    const from = document.createElement("select");
    const to = document.createElement("select");
    for (const id of nodeIds) {
      const optFrom = document.createElement("option");
      optFrom.value = id;
      optFrom.textContent = id;
      from.appendChild(optFrom);
      const optTo = document.createElement("option");
      optTo.value = id;
      optTo.textContent = id;
      to.appendChild(optTo);
    }
    from.value = edge.from || nodeIds[0];
    to.value = edge.to || nodeIds[0];
    const condition = document.createElement("input");
    condition.placeholder = "Condition text";
    condition.value = edge.condition_text || "";
    row.appendChild(from);
    row.appendChild(to);
    row.appendChild(condition);
    kbGuidelineEdges.appendChild(row);
  }
}

function refreshGuidelineEditor(graph) {
  if (!graph) return;
  renderGuidelineNodes(graph.nodes || []);
  renderGuidelineEdges(graph.edges || [], graph.nodes || []);
}

function collectGuidelineGraphFromEditor() {
  if (!kbGuidelineBaseGraph) return null;
  const graph = JSON.parse(JSON.stringify(kbGuidelineBaseGraph));
  const nodes = [];
  kbGuidelineNodes?.querySelectorAll(".kb-editor-row").forEach(row => {
    const inputs = row.querySelectorAll("input, select, textarea");
    if (inputs.length < 3) return;
    const label = inputs[0].value.trim();
    const type = inputs[1].value;
    const actions = inputs[2].value.split("\\n").map(v => v.trim()).filter(Boolean);
    const id = row.dataset.nodeId || `node_${nodes.length + 1}`;
    const existing = (graph.nodes || []).find(n => n.id === id) || {};
    nodes.push({ ...existing, id, label, type, actions });
  });
  const edges = [];
  const baseEdges = graph.edges || [];
  kbGuidelineEdges?.querySelectorAll(".kb-editor-row").forEach((row, idx) => {
    const inputs = row.querySelectorAll("input, select");
    if (inputs.length < 3) return;
    const from = inputs[0].value;
    const to = inputs[1].value;
    const condition_text = inputs[2].value.trim();
    const existing = baseEdges[idx] || {};
    edges.push({ ...existing, from, to, condition_text, condition_logic: existing.condition_logic || null });
  });
  graph.nodes = nodes;
  graph.edges = edges;
  return graph;
}

async function openKbGuidelineQA(guidelineId) {
  if (!guidelineId) return;
  kbGuidelineCurrentId = guidelineId;
  setKbGuidelineEditStatus("");
  try {
    const data = await apiGet(`/admin/local_kb/guidelines/${guidelineId}`);
    kbGuidelineBaseGraph = data?.graph || null;
    kbGuidelineDraftGraph = JSON.parse(JSON.stringify(kbGuidelineBaseGraph || {}));
    const assets = data?.assets || [];
    const guideline = data?.guideline || {};
    const preferred = assets.find(a => (a.asset_url || "") === (guideline.source_url || ""));
    const sourceUrl = preferred?.asset_url || assets[0]?.asset_url || guideline.source_url || "";
    if (kbGuidelineSourceLink) kbGuidelineSourceLink.href = sourceUrl || "#";
    if (kbGuidelineFrame) kbGuidelineFrame.src = sourceUrl || "about:blank";
    refreshGuidelineEditor(kbGuidelineDraftGraph);
    openKbGuidelinePanel();
  } catch (err) {
    setKbGuidelineStatus(err?.message || "Failed to load guideline.", true);
  }
}

function addGuidelineNodeRow() {
  if (!kbGuidelineBaseGraph) kbGuidelineBaseGraph = { nodes: [], edges: [], variables: [] };
  const id = `node_${(kbGuidelineBaseGraph.nodes?.length || 0) + 1}`;
  kbGuidelineBaseGraph.nodes = kbGuidelineBaseGraph.nodes || [];
  kbGuidelineBaseGraph.nodes.push({ id, type: "note", label: "", actions: [] });
  refreshGuidelineEditor(kbGuidelineBaseGraph);
}

function addGuidelineEdgeRow() {
  if (!kbGuidelineBaseGraph) return;
  kbGuidelineBaseGraph.edges = kbGuidelineBaseGraph.edges || [];
  const nodes = kbGuidelineBaseGraph.nodes || [];
  if (nodes.length < 2) {
    setKbGuidelineEditStatus("Add at least two nodes before adding an edge.", true);
    return;
  }
  kbGuidelineBaseGraph.edges.push({ from: nodes[0].id, to: nodes[1].id, condition_text: "", condition_logic: null });
  refreshGuidelineEditor(kbGuidelineBaseGraph);
}

async function saveGuidelinePatch() {
  if (!kbGuidelineCurrentId) return;
  const graph = collectGuidelineGraphFromEditor();
  if (!graph) return;
  setKbGuidelineEditStatus("Savingâ€¦");
  try {
    await apiPost(`/admin/local_kb/guidelines/${kbGuidelineCurrentId}/patch`, {
      patch: [{ op: "replace", path: "/", value: graph }],
    });
    setKbGuidelineEditStatus("Patch saved.");
  } catch (err) {
    setKbGuidelineEditStatus(err?.message || "Patch save failed.", true);
  }
}

async function reextractGuideline() {
  if (!kbGuidelineCurrentId) return;
  setKbGuidelineEditStatus("Re-extractingâ€¦");
  try {
    await apiPost(`/admin/local_kb/guidelines/${kbGuidelineCurrentId}/reextract`, {});
    setKbGuidelineEditStatus("Re-extracted.");
    await openKbGuidelineQA(kbGuidelineCurrentId);
  } catch (err) {
    setKbGuidelineEditStatus(err?.message || "Re-extract failed.", true);
  }
}

function openProfilePanel() {
  if (!profilePanel || !profileOverlay) return;
  setProfileStatus("");
  profileOverlay.style.display = "block";
  profilePanel.style.display = "flex";
  loadProfile();
}

function closeProfilePanel() {
  if (!profilePanel || !profileOverlay) return;
  profileOverlay.style.display = "none";
  profilePanel.style.display = "none";
}

function setProfileStatus(message, isError=false) {
  if (!profileStatus) return;
  profileStatus.textContent = message || "";
  profileStatus.className = "macro-status" + (isError ? " error" : "");
}

async function loadProfile() {
  try {
    const data = await apiGet("/auth/profile");
    const profile = data?.profile || {};
    profileCache = profile;
    if (profileSignatureName) profileSignatureName.value = profile.signature_name || "";
    if (profileCpsa) profileCpsa.value = profile.cpsa || "";
    if (profileDefaultFundingModel) {
      profileDefaultFundingModel.value = (profile.default_funding_model || "FFS").toUpperCase();
    }
    if (profileClinicName) profileClinicName.value = profile.clinic_name || "";
    if (profileClinicAddress) profileClinicAddress.value = profile.clinic_address || "";
    if (profileClinicPhone) profileClinicPhone.value = profile.clinic_phone || "";
    if (profileClinicFax) profileClinicFax.value = profile.clinic_fax || "";
  } catch (err) {
    setProfileStatus(err?.message || "Failed to load profile.", true);
  }
}

async function saveProfile() {
  const payload = {
    signature_name: (profileSignatureName?.value || "").trim(),
    cpsa: (profileCpsa?.value || "").trim(),
    default_funding_model: (profileDefaultFundingModel?.value || "").trim(),
    clinic_name: (profileClinicName?.value || "").trim(),
    clinic_address: (profileClinicAddress?.value || "").trim(),
    clinic_phone: (profileClinicPhone?.value || "").trim(),
    clinic_fax: (profileClinicFax?.value || "").trim(),
  };
  try {
    setProfileStatus("Savingâ€¦");
    await apiPut("/auth/profile", payload);
    profileCache = { ...payload };
    setProfileStatus("Saved.");
  } catch (err) {
    setProfileStatus(err?.message || "Save failed.", true);
  }
}

function extractLastNameFromSignature(signature) {
  const raw = String(signature || "").trim();
  if (!raw) return "";
  let cleaned = raw.replace(/^dr\.?\s+/i, "").replace(/[,]+/g, " ").trim();
  const tokens = cleaned.split(/\s+/);
  const stopTokens = new Set([
    "MD", "M.D", "PHD", "PH.D", "CCFP", "FRCPC", "FRCP", "FRCSC", "MBBS", "DO", "MSC", "BSC", "MPH",
  ]);
  const nameParts = [];
  for (const token of tokens) {
    const norm = token.replace(/[.]/g, "").toUpperCase();
    if (stopTokens.has(norm)) break;
    nameParts.push(token);
  }
  if (nameParts.length === 0) return "";
  return nameParts[nameParts.length - 1];
}

async function getPhysicianPrintName() {
  let signature = (profileCache?.signature_name || "").trim();
  if (!signature && profileSignatureName?.value) {
    signature = profileSignatureName.value.trim();
  }
  if (!signature) {
    try {
      const data = await apiGet("/auth/profile");
      profileCache = data?.profile || profileCache;
      signature = (profileCache?.signature_name || "").trim();
    } catch {}
  }
  const lastName = extractLastNameFromSignature(signature);
  return lastName ? `Dr. ${lastName}` : "Dr.";
}

function setFeedbackStatus(message, isError=false) {
  if (!feedbackStatus) return;
  feedbackStatus.textContent = message || "";
  feedbackStatus.className = "macro-status" + (isError ? " error" : "");
}

function maybeStoreFeedbackEmail(email) {
  const value = (email || "").trim();
  if (!value) return;
  const adminEmail = (authUser?.is_admin && authUser?.email) ? authUser.email.trim().toLowerCase() : "";
  if (adminEmail && value.toLowerCase() === adminEmail) return;
  try { localStorage.setItem(FEEDBACK_EMAIL_KEY, value); } catch {}
}

async function sendFeedback() {
  const email = (feedbackEmail?.value || "").trim();
  const message = (feedbackMessage?.value || "").trim();

  const resolvedEmail = email || (authUser?.email || "");
  if (!resolvedEmail) {
    setFeedbackStatus("Please enter your email.", true);
    return;
  }
  if (!message) {
    setFeedbackStatus("Please enter feedback.", true);
    return;
  }

  try {
    const headers = { "Content-Type": "application/json", ...authHeaders() };
    if (sessionId) headers["X-Session-Id"] = sessionId;
    const res = await fetchWithTimeout(`${API_BASE}/feedback`, {
      method: "POST",
      headers,
      body: JSON.stringify({ email: resolvedEmail, message }),
    });
    if (!res.ok) {
      let detail = null;
      try { detail = await res.json(); } catch {}
      const code = detail?.detail?.code || detail?.code || "";
      const msg = detail?.detail?.message || detail?.message || detail?.detail || res.statusText;
      const label = code ? `Error (${code}): ${msg}` : `Error: ${msg}`;
      setFeedbackStatus(label, true);
      return;
    }
    setFeedbackStatus("");
    if (feedbackMessage) feedbackMessage.value = "";
    maybeStoreFeedbackEmail(resolvedEmail);
    showToast("Feedback sent.", "ok");
    closeFeedbackPanel();
  } catch (err) {
    setFeedbackStatus(err?.message || "Send failed.", true);
  }
}

function openReferralPanel() {
  if (!referralPanel || !referralOverlay) return;
  setReferralStatus("");
  setReferralMissing(null);
  referralOverlay.style.display = "block";
  referralPanel.style.display = "flex";
  if (referralSpecialtyInput) referralSpecialtyInput.value = "";
  generateReferralDraft("");
}

function closeReferralPanel() {
  if (!referralPanel || !referralOverlay) return;
  referralOverlay.style.display = "none";
  referralPanel.style.display = "none";
}

function setReferralStatus(message, isError=false) {
  if (!referralStatus) return;
  referralStatus.textContent = message || "";
  referralStatus.className = "macro-status" + (isError ? " error" : "");
}

function setNoteDraftStatus(message, isError=false) {
  if (!noteDraftStatus) return;
  noteDraftStatus.textContent = message || "";
  noteDraftStatus.className = "macro-status" + (isError ? " error" : "");
}

function setNoteDraftLoading(on) {
  if (noteDraftLoading) noteDraftLoading.classList.toggle("active", Boolean(on));
  if (noteDraftCopyBtn) noteDraftCopyBtn.disabled = Boolean(on);
  if (noteDraftText) noteDraftText.disabled = Boolean(on);
}

function activateNoteDraftFocusTrap() {
  if (!noteDraftPanel) return;
  noteDraftActive = true;
  const focusable = Array.from(noteDraftPanel.querySelectorAll(
    "button, textarea, input, select, [tabindex]:not([tabindex='-1'])"
  )).filter(el => !el.disabled);
  const first = focusable[0] || noteDraftPanel;
  const last = focusable[focusable.length - 1] || first;

  noteDraftKeyHandler = (e) => {
    if (e.key === "Escape") {
      e.preventDefault();
      closeNoteDraftPanel();
      return;
    }
    if (e.key !== "Tab") return;
    if (focusable.length <= 1) return;
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  };
  noteDraftPanel.addEventListener("keydown", noteDraftKeyHandler);
  setTimeout(() => { try { first.focus(); } catch {} }, 0);
}

function deactivateNoteDraftFocusTrap() {
  if (noteDraftPanel && noteDraftKeyHandler) {
    noteDraftPanel.removeEventListener("keydown", noteDraftKeyHandler);
  }
  noteDraftKeyHandler = null;
  noteDraftActive = false;
}

async function openNoteDraftPanel({ templateId, templateLabel, generate }) {
  if (!noteDraftPanel || !noteDraftOverlay) return;
  noteDraftTemplateId = String(templateId || "");
  noteDraftTemplateLabel = String(templateLabel || "Note");
  if (noteDraftTitle) noteDraftTitle.textContent = noteDraftTemplateLabel;
  if (noteDraftText) noteDraftText.value = "";
  setNoteDraftStatus("");
  setNoteDraftLoading(true);
  noteDraftOverlay.style.display = "block";
  noteDraftPanel.style.display = "flex";
  activateNoteDraftFocusTrap();
  try {
    const text = await generate();
    if (noteDraftText) noteDraftText.value = text || "";
    setNoteDraftStatus(text ? "" : "No content returned.", !text);
  } catch (err) {
    setNoteDraftStatus(err?.message || "Generation failed.", true);
  } finally {
    setNoteDraftLoading(false);
  }
}

function closeNoteDraftPanel() {
  if (!noteDraftPanel || !noteDraftOverlay) return;
  noteDraftOverlay.style.display = "none";
  noteDraftPanel.style.display = "none";
  setNoteDraftStatus("");
  setNoteDraftLoading(false);
  deactivateNoteDraftFocusTrap();
}

async function generateSoapDraft() {
  await ensureSession();
  const data = await apiPost(`/session/${sessionId}/make_soap`);
  const soapTextRaw = data?.soap || data?.soap_text || "No SOAP returned";
  return stripPairedMarkdownEmphasis(soapTextRaw);
}

async function generateTemplateDraft(macroContent, modelOverride="gpt-5-nano") {
  await ensureSession();
  const payload = { query: "", mode: "fast", macro: macroContent };
  if (modelOverride) payload.model = modelOverride;
  const data = await apiPost(`/session/${sessionId}/clinical_query`, payload);
  const rawContent = (data?.response !== undefined) ? data.response : data;
  const readable = readableFromMaybeJson(rawContent);
  return stripPairedMarkdownEmphasis(readable);
}

async function generateRxDraft() {
  const transcript = (transcriptBox?.value || "").trim();
  const emr = (emrBackgroundText || "").trim();
  const rxPrompt = `
TASK: RX_RECOMMENDATION_CANADA

Use ONLY today's transcript and EMR background. Do not invent diagnoses, meds, or allergies.
If there is not enough information to recommend a prescription, return exactly:
Insufficient information to recommend a prescription.

Requirements:
- Prefer Canadian/Alberta-available medications.
- Check interactions against listed meds and allergies; if a conflict exists, do NOT suggest that drug.
- If no med list or allergies are provided, state that explicitly in the interaction/allergy line.
- Suggest at most 1â€“2 options.

Output format (plain text, no bullets):
Prescription:
<Drug name + strength> | <form (tab/cap/puff/ml)> | <frequency> | <duration> | <PRN or scheduled> | <total quantity> | <route>
Instructions: <how to take/administer>
Side effects to monitor: <short list>
Interaction/allergy check: <state checks; if issue, give alternative line>

TRANSCRIPT:
${transcript || "[none]"}

EMR:
${emr || "[none]"}
`.trim();

  return await generateTemplateDraft(rxPrompt, "gpt-5-nano");
}

const REFERRAL_MISSING_LABELS = {
  "referral.specialty_name": "specialty",
  "referral.reason_short": "reason for referral",
  "referral.urgency_label": "urgency",
};
let referralMissingCriticalLabels = [];

function setReferralLoading(on) {
  if (!referralLoading) return;
  referralLoading.classList.toggle("active", Boolean(on));
}

function referralTextToHtml(text) {
  const esc = (s) =>
    String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;");
  const html = esc(text).replace(/\n/g, "<br>");
  if (!referralMissingCriticalLabels.length) return html;
  return referralMissingCriticalLabels.reduce((acc, label) => {
    const re = new RegExp(`\\[MISSING: ${label.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&")}\\]`, "g");
    return acc.replace(re, (match) => `<span class="missing-critical">${match}</span>`);
  }, html);
}

function setReferralMissing(quality) {
  if (!referralMissing) return;
  if (!quality) {
    referralMissing.textContent = "";
    referralMissing.className = "macro-status";
    referralMissingCriticalLabels = [];
    return;
  }
  const missingCritical = Array.isArray(quality.missing_critical) ? quality.missing_critical : [];
  const missingRecommended = Array.isArray(quality.missing_recommended) ? quality.missing_recommended : [];
  const warnings = Array.isArray(quality.warnings) ? quality.warnings : [];
  const lines = [];
  if (missingCritical.length) lines.push(`Missing (critical): ${missingCritical.join(", ")}`);
  if (missingRecommended.length) lines.push(`Missing (recommended): ${missingRecommended.join(", ")}`);
  if (warnings.length) lines.push(`Warnings: ${warnings.join(", ")}`);
  referralMissing.textContent = lines.join("\n");
  referralMissing.className = "macro-status" + (lines.length ? " error" : "");
  referralMissingCriticalLabels = missingCritical
    .map((key) => REFERRAL_MISSING_LABELS[key])
    .filter(Boolean);
}

async function generateReferralDraft(specialtyOverride="") {
  await ensureSession();
  setReferralStatus("Generatingâ€¦");
  setReferralMissing(null);
  setReferralLoading(true);
  if (referralLetterText) referralLetterText.innerHTML = "";

  try {
    const override = String(specialtyOverride || "").trim();
    const payload = {
      session_id: sessionId,
      specialty: override,
      subspecialty_or_clinic: "",
      reason_short: "",
      consult_question: "",
      urgency_override: null,
      include_objective: true,
    };
    const data = await apiPost("/referral_draft", payload);
    const inferred = String(data?.referral_json?.referral?.specialty_name || "").trim();
    if (referralSpecialtyInput && !override && inferred) {
      referralSpecialtyInput.value = inferred;
    }
    const letter = String(data?.letter_text || "").trim();
    setReferralMissing(data?.quality || null);
    if (referralLetterText) referralLetterText.innerHTML = referralTextToHtml(letter);
    setReferralStatus("Draft ready.");
  } catch (err) {
    setReferralStatus(err?.message || "Draft failed.", true);
  } finally {
    setReferralLoading(false);
  }
}

async function copyReferralDraft() {
  const text = (referralLetterText?.textContent || "").trim();
  if (!text) {
    setReferralStatus("Generate a draft first.", true);
    return;
  }
  const ok = await copyRichText(text);
  if (ok) {
    showToast("Referral copied.", "ok");
    setReferralStatus("");
    return;
  }
  setReferralStatus("Copy blocked. Use manual copy.", true);
}

function openBillingArchivePanel() {
  if (!billingArchivePanel || !billingArchiveOverlay) return;
  billingArchiveOverlay.style.display = "block";
  billingArchivePanel.style.display = "flex";
}

function closeBillingArchivePanel() {
  if (!billingArchivePanel || !billingArchiveOverlay) return;
  billingArchiveOverlay.style.display = "none";
  billingArchivePanel.style.display = "none";
}

function formatArchiveLabel(item) {
  const iso = String(item?.saved_at_local || "").trim();
  if (iso.length >= 16) return `${iso.slice(0, 16).replace("T", " ")}`;
  return item?.filename || "Saved billing";
}

function refreshBillingArchiveSelect() {
  if (!billingArchiveSelect) return;
  billingArchiveSelect.innerHTML = "";
  const def = document.createElement("option");
  def.value = "";
  def.textContent = "Select saved billing";
  billingArchiveSelect.appendChild(def);
  for (const item of billingArchiveItems) {
    const opt = document.createElement("option");
    opt.value = item.filename;
    opt.textContent = `${formatArchiveLabel(item)} â€¢ ${item.filename}`;
    billingArchiveSelect.appendChild(opt);
  }
  billingArchiveSelect.value = billingArchiveCurrent || "";
  if (billingArchiveDeleteBtn) {
    billingArchiveDeleteBtn.disabled = !billingArchiveCurrent;
  }
}

async function loadBillingArchives() {
  const data = await apiGet("/billing/archives");
  billingArchiveItems = Array.isArray(data?.items) ? data.items : [];
  if (!billingArchiveItems.length) {
    billingArchiveCurrent = "";
    billingArchiveCurrentMeta = null;
    if (billingArchiveText) billingArchiveText.value = "";
    if (billingArchiveMeta) billingArchiveMeta.textContent = "No saved billings yet.";
  }
  refreshBillingArchiveSelect();
  if (billingArchiveItems.length && !billingArchiveCurrent) {
    await loadBillingArchive(billingArchiveItems[0].filename);
  }
}

async function loadBillingArchive(name) {
  if (!name) return;
  const data = await apiGet(`/billing/archives/${encodeURIComponent(name)}`);
  billingArchiveCurrent = name;
  billingArchiveCurrentMeta = data || null;
  if (billingArchiveText) billingArchiveText.value = String(data?.text || "");
  if (billingArchiveMeta) {
    const saved = String(data?.saved_at_local || "").replace("T", " ").slice(0, 16);
    const total = data?.total_patient_count;
    billingArchiveMeta.textContent = saved ? `Saved: ${saved}${total !== undefined ? ` â€¢ Total: ${total}` : ""}` : "";
  }
  refreshBillingArchiveSelect();
}

async function saveBillingArchive() {
  if (!billingArchiveCurrent) {
    logChat("System", "Select a saved billing first.");
    return;
  }
  const text = billingArchiveText?.value || "";
  const data = await apiPut(`/billing/archives/${encodeURIComponent(billingArchiveCurrent)}`, { text });
  if (billingArchiveMeta) {
    const saved = String(data?.saved_at_local || "").replace("T", " ").slice(0, 16);
    const total = data?.total_patient_count;
    billingArchiveMeta.textContent = saved ? `Saved: ${saved}${total !== undefined ? ` â€¢ Total: ${total}` : ""}` : "";
  }
  logChat("System", "Saved billing updated.");
}

async function deleteBillingArchive() {
  if (!billingArchiveCurrent) {
    logChat("System", "Select a saved billing first.");
    return;
  }
  const name = billingArchiveCurrent;
  const ok = window.confirm(`Delete saved billing "${name}"? This cannot be undone.`);
  if (!ok) return;
  await apiDelete(`/billing/archives/${encodeURIComponent(name)}`);
  billingArchiveCurrent = "";
  billingArchiveCurrentMeta = null;
  if (billingArchiveText) billingArchiveText.value = "";
  if (billingArchiveMeta) billingArchiveMeta.textContent = "Deleted.";
  await loadBillingArchives();
  logChat("System", "Saved billing deleted.");
}

function openBillingPrintWindow(printable, metaDate, metaCount, physicianName) {
  const w = window.open("", "_blank");
  if (!w) { logChat("System", "Pop-up blocked. Allow pop-ups to print."); return; }
  const displayName = (physicianName || "Dr.").trim();
  const safeText = String(printable || "").replace(/[&<>]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]));

  w.document.open();
  w.document.write(`
    <html>
    <head>
      <title>Physician: ${escapeHtml(displayName)}</title>
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 24px; }
        h1 { font-size: 18px; margin: 0 0 10px 0; }
        .meta { font-size: 12px; margin-bottom: 16px; color: #444; }
        pre { white-space: pre-wrap; font-size: 12px; line-height: 1.35; }
      </style>
    </head>
    <body>
      <h1>Physician: ${escapeHtml(displayName)}</h1>
      <div class="meta">
        Date: ${escapeHtml(metaDate || todayStrLocal())} &nbsp;|&nbsp;
        Total: ${escapeHtml(String(metaCount ?? ""))}
      </div>
      <pre>${safeText}</pre>
    </body>
    </html>
  `);
  w.document.close();
  try {
    w.focus();
    w.print();
  } catch {}
}

function getArchiveMetaDate(meta) {
  const saved = String(meta?.saved_at_local || "");
  if (!saved) return "";
  return saved.split("T")[0];
}

async function reprintBillingArchive() {
  if (!billingArchiveCurrent) {
    logChat("System", "Select a saved billing first.");
    return;
  }
  const text = billingArchiveText?.value || "";
  const total = countPatientsFromText(text);
  const metaDate = getArchiveMetaDate(billingArchiveCurrentMeta) || todayStrLocal();
  const physicianName = await getPhysicianPrintName();
  openBillingPrintWindow(text, metaDate, total, physicianName);
}

// -------------------------
// Theme
// -------------------------
const THEME_KEY = "centaur_theme_v1";

function normalizeTheme(t) {
  return (String(t || "").toLowerCase() === "dark") ? "dark" : "light";
}

function applyTheme(theme) {
  const t = normalizeTheme(theme);
  document.documentElement.dataset.theme = t;
  try { refreshMicVizPalette(); } catch {}
}

function getThemePref() {
  return normalizeTheme(localStorage.getItem(THEME_KEY) || "dark");
}

function setThemePref(theme) {
  const t = normalizeTheme(theme);
  localStorage.setItem(THEME_KEY, t);
  applyTheme(t);
  return t;
}

function initTheme() {
  applyTheme(getThemePref());
}

function toggleTheme() {
  const current = getThemePref();
  const next = current === "dark" ? "light" : "dark";
  setThemePref(next);
}

// -------------------------
// Ambient UI state machine
// -------------------------
function setWaveformState(state) {
  if (!waveformBtn) return;
  waveformBtn.classList.remove("recording", "paused", "initializing", "error");
  waveformBtn.classList.add(state);
}

function updateAmbientUI(status) {
  const txPill = document.getElementById("tx_state");
  if (status === "listening") {
    if (txPill) setPill(txPill, "LISTENING", "live");
    setWaveformState("recording");
  } else if (status === "paused") {
    if (txPill) setPill(txPill, "PAUSED", "warn");
    setWaveformState("paused");
  } else if (status === "offline") {
    if (txPill) setPill(txPill, "OFFLINE", "warn");
    setWaveformState("paused");
  } else if (status === "error") {
    if (txPill) setPill(txPill, "ERROR", "warn");
    setWaveformState("error");
  } else {
    if (txPill) setPill(txPill, "INITIALIZING", "");
    setWaveformState("initializing");
  }
}

// -------------------------
// Wake Lock
// -------------------------
async function requestWakeLock() {
  if (!("wakeLock" in navigator)) return;
  try {
    wakeLockSentinel = await navigator.wakeLock.request("screen");
    wakeLockSentinel.addEventListener("release", () => {
      wakeLockSentinel = null;
    });
  } catch (err) {
    console.warn("Wake lock failed:", err);
  }
}
async function releaseWakeLock() {
  try { await wakeLockSentinel?.release(); } catch {}
  wakeLockSentinel = null;
}
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && ambientController?.enabled && !ambientController?.paused) {
    requestWakeLock();
  }
});

// -------------------------
// Patient anchor extraction (best-effort)
// -------------------------
function normalizeDigits(s) { return String(s || "").replace(/\D+/g, ""); }
function sanitizePHNInput(v) {
  const dig = normalizeDigits(v);
  if (!dig) return "";
  // AB PHN is typically 9 digits; some EMRs store 10. Keep up to 10 but allow 9.
  if (dig.length < 9) return "";
  return dig.slice(0, 10);
}
function sanitizeAgeYears(v) {
  const n = parseInt(String(v ?? "").replace(/\D+/g, ""), 10);
  if (!Number.isFinite(n) || n <= 0 || n >= 130) return "";
  return String(n);
}

function titleCaseWord(w){
  const s = String(w || "").trim();
  if (!s) return "";
  if (s.toUpperCase() === s && /[A-Z]/.test(s)) {
    return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
  }
  return s;
}
function titleCaseName(name){
  const parts = String(name || "").trim().split(/\s+/g).filter(Boolean);
  return parts.map(p => {
    if (p.includes("-")) return p.split("-").map(titleCaseWord).join("-");
    return titleCaseWord(p);
  }).join(" ");
}

function extractPHNFromText(text) {
  const t = String(text || "");

  // JSON style
  const mj = t.match(/"phn"\s*:\s*"?(?<phn>[0-9][0-9\s\-]{7,20})"?/i);
  if (mj?.groups?.phn) {
    const dig = sanitizePHNInput(mj.groups.phn);
    if (dig) return dig;
  }

  // Explicit labels (common in Alberta EMRs): "PHN/ULI: 123456789"
  const m0 = t.match(/(?:^|\n)\s*(?:PHN\s*\/\s*ULI|PHN|ULI)\s*[:#=\-]?\s*([0-9][0-9\s\-]{6,20})/i);
  if (m0 && m0[1]) {
    const dig = sanitizePHNInput(m0[1]);
    if (dig) return dig;
  }

  // Header pattern: "(778389621 | AB)" or "778389621 | AB"
  const mAB = t.match(/\b(\d{9,10})\s*\|\s*AB\b/i);
  if (mAB && mAB[1]) {
    const dig = sanitizePHNInput(mAB[1]);
    if (dig) return dig;
  }

  // Other common label lines
  const m1 = t.match(/(?:^|\n)\s*(?:PHN|Personal\s*Health\s*Number)\s*[:#=\-]?\s*([0-9][0-9\s\-]{7,20})/i);
  if (m1 && m1[1]) {
    const dig = sanitizePHNInput(m1[1]);
    if (dig) return dig;
  }

  // Fallback: last 9-digit run anywhere (avoids 10-digit phone #s and 10-digit order #s)
  const all9 = [];
  const re9 = /\b(\d{9})\b/g;
  let m;
  while ((m = re9.exec(t)) !== null) all9.push(m[1]);
  if (all9.length) {
    const dig = sanitizePHNInput(all9[all9.length - 1]);
    if (dig) return dig;
  }

  return "";
}

function extractNameFromText(text) {
  const t = String(text || "");
  const head = t.slice(0, 1400); // patient header is usually near top

  // Prefer "LASTNAME, Firstname" near header
  let m = head.match(/(?:^|\n)\s*([A-Z]{2,}),\s*([A-Z][A-Za-z'\-]+)\b/m);
  if (m && m[1] && m[2]) {
    const last = titleCaseWord(m[1]);
    const first = titleCaseWord(m[2]);
    const nm = `${first} ${last}`.trim();
    if (nm && !/\bdr\b/i.test(nm)) return nm;
  }

  // Prefer "Lastname, Firstname" near header
  m = head.match(/(?:^|\n)\s*([A-Z][A-Za-z'\-]{1,}),\s*([A-Z][A-Za-z'\-]+)\b/m);
  if (m && m[1] && m[2]) {
    const last = titleCaseWord(m[1]);
    const first = titleCaseWord(m[2]);
    const nm = `${first} ${last}`.trim();
    if (nm && !/\bdr\b/i.test(nm)) return nm;
  }

  // JSON-style
  const mj = t.match(/"patient_name"\s*:\s*"(?<name>[^"]{3,80})"/i) || t.match(/"name"\s*:\s*"(?<name>[^"]{3,80})"/i);
  if (mj?.groups?.name) {
    const name = mj.groups.name.trim();
    if (name && /[A-Za-z]/.test(name)) return titleCaseName(name);
  }

  // Label-based (rare)
  const m0 = t.match(/(?:^|\n)\s*(?:Name\s+of\s+patient|Patient\s+Name|Patient)\s*[:#=\-]\s*([A-Z][A-Za-z'\-]+(?:\s+[A-Z][A-Za-z'\-]+){0,5})/i);
  if (m0 && m0[1]) return titleCaseName(m0[1].trim());

  // Fallback: best-effort "Name:" line
  const m1 = t.match(/(?:^|\n)\s*(?:Name|Pt)\s*[:#=\-]\s*([A-Z][A-Za-z'\-]+(?:\s+[A-Z][A-Za-z'\-]+){0,4})/m);
  if (m1 && m1[1]) return titleCaseName(m1[1].trim());

  return "";
}

const DOB_MONTH = {
  jan:"01", january:"01",
  feb:"02", february:"02",
  mar:"03", march:"03",
  apr:"04", april:"04",
  may:"05",
  jun:"06", june:"06",
  jul:"07", july:"07",
  aug:"08", august:"08",
  sep:"09", sept:"09", september:"09",
  oct:"10", october:"10",
  nov:"11", november:"11",
  dec:"12", december:"12",
};

function normalizeDobToISO(raw) {
  const s0 = String(raw || "").trim();
  if (!s0) return "";

  // Remove spaces, keep separators
  const s = s0.replace(/\s+/g, "");

  // YYYY-MM-DD or YYYY/M/D
  let m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
  if (m) {
    const y = m[1];
    const mo = String(parseInt(m[2], 10)).padStart(2, "0");
    const d = String(parseInt(m[3], 10)).padStart(2, "0");
    return `${y}-${mo}-${d}`;
  }

  // YYYY-Mon-DD
  m = s.match(/^(\d{4})[-\/]([A-Za-z]{3,9})[-\/](\d{1,2})$/);
  if (m) {
    const y = m[1];
    const mon = String(m[2] || "").toLowerCase();
    const mo = DOB_MONTH[mon] || DOB_MONTH[mon.slice(0,3)] || "";
    const d = String(parseInt(m[3], 10)).padStart(2, "0");
    if (mo) return `${y}-${mo}-${d}`;
  }

  // DD-Mon-YYYY (e.g., 23-MAY-1984)
  m = s.match(/^(\d{1,2})[-\/]([A-Za-z]{3,9})[-\/](\d{4})$/);
  if (m) {
    const d = String(parseInt(m[1], 10)).padStart(2, "0");
    const mon = String(m[2] || "").toLowerCase();
    const mo = DOB_MONTH[mon] || DOB_MONTH[mon.slice(0,3)] || "";
    const y = m[3];
    if (mo) return `${y}-${mo}-${d}`;
  }

  return "";
}

function computeAgeFromDOBISO(dobIso) {
  const s = String(dobIso || "").trim().replaceAll("/", "-");
  const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return "";
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const d = parseInt(m[3], 10);
  if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return "";
  const today = new Date();
  const dob = new Date(Date.UTC(y, mo, d));
  if (isNaN(dob.getTime())) return "";
  let age = today.getFullYear() - y;
  const thisYearsBirthday = new Date(today.getFullYear(), mo, d);
  if (today < thisYearsBirthday) age -= 1;
  if (!Number.isFinite(age) || age <= 0 || age >= 130) return "";
  return String(age);
}

function extractAgeFromText(text) {
  const t = String(text || "");

  const mj = t.match(/"age"\s*:\s*"?(?<age>\d{1,3})"?/i);
  if (mj?.groups?.age) {
    const a = sanitizeAgeYears(mj.groups.age);
    if (a) return a;
  }

  const m1 = t.match(/(?:^|\n)\s*Age\s*[:#=\-]?\s*(\d{1,3})\b/i);
  if (m1 && m1[1]) {
    const a = sanitizeAgeYears(m1[1]);
    if (a) return a;
  }

  // "22 yr old", "22 years old", "22 y/o"
  const m2 =
    t.match(/\b(\d{1,3})\s*(?:years?|yrs?|yr)\s*old\b/i) ||
    t.match(/\b(\d{1,3})\s*(?:y\/o|yo)\b/i);
  if (m2 && m2[1]) {
    const a = sanitizeAgeYears(m2[1]);
    if (a) return a;
  }

  // DOB labeled
  const m3 = t.match(/(?:^|\n)\s*(?:DOB|Date\s*of\s*Birth)\s*[:#=\-]?\s*([0-9A-Za-z\/\-]{8,20})\b/i);
  if (m3 && m3[1]) {
    const iso = normalizeDobToISO(m3[1]);
    if (iso) {
      const a = computeAgeFromDOBISO(iso);
      if (a) return a;
    }
  }

  // Header-style DOB line: "2003-May-20" followed nearby by "22 yr old ..."
  const m4 = t.match(/\b(\d{4}[-\/][A-Za-z]{3,9}[-\/]\d{1,2})\b[\s\S]{0,120}\b(\d{1,3})\s*(?:yr|yrs|years)\s*old\b/i);
  if (m4 && m4[1]) {
    const iso = normalizeDobToISO(m4[1]);
    if (iso) {
      const a = computeAgeFromDOBISO(iso);
      if (a) return a;
    }
    const a2 = sanitizeAgeYears(m4[2]);
    if (a2) return a2;
  }

  return "";
}

function parseAnchorFromSnapshot() {
  const snap = String(snapshotPanel?.textContent || "").trim();
  if (!snap) return { nm:"", phn:"", age:"" };
  if (snap.startsWith("{") || snap.startsWith("[")) {
    try {
      const parsed = JSON.parse(snap);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        const nm = String(parsed.patient_name || parsed.name || "").trim();
        const phn = sanitizePHNInput(parsed.phn || parsed.patient_phn || "");
        const age = sanitizeAgeYears(parsed.age || "");
        return { nm, phn, age };
      }
    } catch {}
  }
  return {
    nm: extractNameFromText(snap),
    phn: extractPHNFromText(snap),
    age: extractAgeFromText(snap),
  };
}
function setPatientAnchorFromTextBestEffort(text) {
  const nm = extractNameFromText(text);
  const phn = extractPHNFromText(text);
  const age = extractAgeFromText(text);
  if (nm && nm !== patientName) patientName = nm;
  if (phn && phn !== patientPHN) patientPHN = phn;
  if (age && age !== patientAge) patientAge = age;
}
function refreshPatientAnchorFromSnapshotPreferred() {
  const { nm, phn, age } = parseAnchorFromSnapshot();
  if (nm) patientName = nm;
  if (phn) patientPHN = phn;
  if (age) patientAge = age;
}

// -------------------------
// Frontend Patient Summary (MINIMAL TEMPLATE + best-effort extraction)
// -------------------------
function lastMatch(re, text, groupIndex=1) {
  const src = re instanceof RegExp ? re : new RegExp(String(re));
  const flags = src.flags.includes("g") ? src.flags : (src.flags + "g");
  const rg = new RegExp(src.source, flags);
  let m = null;
  let last = null;
  while ((m = rg.exec(text)) !== null) last = m;
  if (!last) return "";
  if (last.groups && typeof last.groups.val === "string") return last.groups.val.trim();
  return String(last[groupIndex] || "").trim();
}
function cleanInline(s) {
  return String(s || "")
    .replace(/\s+/g, " ")
    .replace(/\s*[|â€¢]\s*/g, " | ")
    .replace(/\s*,\s*$/g, "")
    .trim();
}
function extractLineValue(label, text) {
  const t = String(text || "");
  const re = new RegExp(String.raw`(?:^|\n)\s*${label}\s*[:#=\-]\s*(?<val>[^\n]{0,220})`, "ig");
  return lastMatch(re, t, 1);
}

function extractGenderFromText(text) {
  const t = String(text || "");
  let g = extractLineValue("(?:Sex|Gender)", t);

  if (!g || !String(g).trim()) {
    const m =
      t.match(/\b(?:\d{1,3})\s*(?:yr|yrs|years)\s*old\s*(male|female)\b/i) ||
      t.match(/\b(male|female)\b/i);
    if (m && m[1]) g = m[1];
    else if (m && m[0]) g = m[0];
  }

  g = cleanInline(g);
  if (!g) return "";

  const u = g.toUpperCase();
  if (u === "M" || u === "MALE") return "M";
  if (u === "F" || u === "FEMALE") return "F";
  return g;
}

function extractDOBISO(text) {
  const t = String(text || "").trim();

  const labeled = lastMatch(/(?:^|\n)\s*(?:DOB|Date\s*of\s*Birth)\s*[:#=\-]?\s*(?<val>[0-9A-Za-z\/\-]{8,20})\b/ig, t, 1);
  if (labeled) {
    const iso = normalizeDobToISO(labeled);
    if (iso) return iso;
  }

  const mHeader = t.match(/\b(\d{4}[-\/][A-Za-z]{3,9}[-\/]\d{1,2})\b[\s\S]{0,140}\b(\d{1,3})\s*(?:yr|yrs|years)\s*old\b/i);
  if (mHeader && mHeader[1]) {
    const iso = normalizeDobToISO(mHeader[1]);
    if (iso) return iso;
  }

  return "";
}

function computeAgeDisplayFromDOB(dobIso) {
  const s = String(dobIso || "").trim().replaceAll("/", "-");
  const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return "";
  const y = parseInt(m[1], 10);
  const mo = parseInt(m[2], 10) - 1;
  const d = parseInt(m[3], 10);
  if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return "";
  const today = new Date();
  const months = (today.getFullYear() - y) * 12 + (today.getMonth() - mo) - (today.getDate() < d ? 1 : 0);
  if (!Number.isFinite(months) || months < 0) return "";
  if (months < 24) return `${months} months`;
  let years = today.getFullYear() - y;
  const thisYearsBirthday = new Date(today.getFullYear(), mo, d);
  if (today < thisYearsBirthday) years -= 1;
  if (!Number.isFinite(years) || years <= 0 || years >= 130) return "";
  return `${years} years`;
}
function extractAgeDisplay(text) {
  const t = String(text || "");

  const dob = extractDOBISO(t);
  if (dob) {
    const disp = computeAgeDisplayFromDOB(dob);
    if (disp) return disp;
  }

  const mo = lastMatch(/(?:^|\n)\s*Age\s*[:#=\-]?\s*(?<val>\d{1,2})\s*(?:months?|mos?|mo)\b/ig, t, 1);
  if (mo) {
    const n = parseInt(mo.replace(/\D+/g, ""), 10);
    if (Number.isFinite(n) && n >= 0 && n < 24) return `${n} months`;
  }

  const m2 =
    t.match(/\b(\d{1,3})\s*(?:years?|yrs?|yr)\s*old\b/i) ||
    t.match(/\bAge\s*[:#=\-]?\s*(\d{1,3})\b/i);
  if (m2 && m2[1]) {
    const n = parseInt(m2[1], 10);
    if (Number.isFinite(n) && n > 0 && n < 130) return `${n} years`;
  }

  const yrs = extractAgeFromText(t);
  if (yrs) {
    const n = parseInt(yrs, 10);
    if (Number.isFinite(n) && n > 0) return `${n} years`;
  }
  return "";
}

// --- Social-field sanity filtering (prevents â€œOccupation: Prediabetes â€¦â€)
function looksClinicalValue(v) {
  const s = String(v || "").trim();
  if (!s) return false;
  if (/\b\d+(\.\d+)?\s*(mg|mcg|g|units|iu|mmol\/l|mmol|umol\/l|g\/l|%|bpm)\b/i.test(s)) return true;
  if (/\b(hba1c|a1c|bp|htn|dm|diabet|prediabet|copd|ckd|asthma|hypothy|hyperthy|hyperlip|dyslip|cad|cva|tia|afib|mi|angina)\b/i.test(s)) return true;
  if (/\b(metformin|insulin|semaglutide|ozempic|wegovy|statin|atorvastatin|rosuvastatin|ramipril|lisinopril|amlodipine|losartan|valsartan|apixaban|rivaroxaban|warfarin|levothyroxine)\b/i.test(s)) return true;
  if (/\b(problem|diagnos(?:is|es)|dx)\b\s*[:\-]/i.test(s)) return true;
  return false;
}
function sanitizeSocialValue(v, maxLen=90) {
  let s = cleanInline(v);
  if (!s) return "";
  if (s.length > maxLen) return "";
  if (looksClinicalValue(s)) return "";
  const digits = (s.match(/\d/g) || []).length;
  if (digits >= 6) return "";
  return s;
}

// Family member NAMES only (best-effort)
const FAMILY_STOPWORDS = new Set([
  "Dr","MD","CCFP","PhD",
  "Husband","Wife","Partner","Spouse","Son","Daughter","Child","Children","Kids","Kid",
  "Father","Mother","Dad","Mom","Brother","Sister","Grandfather","Grandmother","Grandpa","Grandma",
  "Lives","With","And","Or","The","A","An","Of"
].map(x => x.toLowerCase()));

function extractNamesFromFreeText(v) {
  const s = String(v || "").replace(/\r\n/g,"\n").replace(/\r/g,"\n");
  if (!s.trim()) return [];

  // Drop parenthetical roles/ages: "(12yo)", "(daughter)", etc.
  const cleaned = s
    .replace(/$begin:math:text$\\s\*\[\^\)\]\*\\s\*$end:math:text$/g, " ")
    .replace(/\b\d{1,3}\s*(?:yo|y\/o|yrs?|years?|months?|mos?)\b/ig, " ")
    .replace(/[^\w'\-\s,]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

  // Candidate names: Capitalized words sequences (1-3 tokens)
  const re = /\b([A-Z][a-zA-Z'\-]{1,})(?:\s+([A-Z][a-zA-Z'\-]{1,}))?(?:\s+([A-Z][a-zA-Z'\-]{1,}))?\b/g;
  const out = [];
  let m;
  while ((m = re.exec(cleaned)) !== null) {
    const parts = [m[1], m[2], m[3]].filter(Boolean);
    if (!parts.length) continue;
    const joined = parts.join(" ").trim();

    const words = joined.split(/\s+/g);
    if (words.every(w => FAMILY_STOPWORDS.has(w.toLowerCase()))) continue;
    if (FAMILY_STOPWORDS.has(words[0].toLowerCase())) continue;

    // reject obvious clinic/provider org strings
    if (/\b(Clinic|Medical|Associate|Airdrie|Alberta|One\s*Health)\b/i.test(joined)) continue;

    out.push(joined);
  }

  const seen = new Set();
  const dedup = [];
  for (const n of out) {
    const key = n.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    dedup.push(n);
  }
  return dedup.slice(0, 12).map(titleCaseName);
}

function extractFamilyMembersNames(text) {
  const t = String(text || "");
  let v =
    extractLineValue("Family\\s*members(?:\\s*names)?", t) ||
    extractLineValue("Lives?\\s*with", t) ||
    extractLineValue("Household", t) ||
    extractLineValue("Spouse|Partner|Husband|Wife|Children|Kids", t) ||
    "";
  v = sanitizeSocialValue(v, 160);
  if (!v) return "";
  const names = extractNamesFromFreeText(v);
  return names.length ? names.join(", ") : "";
}

function extractOccupation(text) {
  const t = String(text || "");
  let v = extractLineValue("Occupation|Job|Work", t);
  if (!v) v = lastMatch(/(?:^|\n)\s*(?:Works?\s+as|Employed\s+as)\s*(?<val>[^\n]{0,220})/ig, t, 1);
  return sanitizeSocialValue(v, 90);
}
function extractHobbies(text) {
  const t = String(text || "");
  let v = extractLineValue("Hobbies|Interests", t);
  if (!v) v = lastMatch(/(?:^|\n)\s*(?:Enjoys?|Likes?)\s*(?<val>[^\n]{0,220})/ig, t, 1);
  return sanitizeSocialValue(v, 110);
}
function extractRecentSocialLife(text) {
  const t = String(text || "");
  let v =
    extractLineValue("Social\\s*History|Social\\s*Hx|Social", t) ||
    lastMatch(/(?:^|\n)\s*Social\s*(?:History|Hx)\s*[:#=\-]?\s*(?<val>[^\n]{0,220})/ig, t, 1) ||
    "";
  return sanitizeSocialValue(v, 140);
}

function buildPatientSummaryText(backgroundText, transcriptText) {
  const bg = String(backgroundText || "");
  const tx = String(transcriptText || "");
  const src = (bg.trim().length ? bg : "") + (bg.trim().length && tx.trim().length ? "\n\n" : "") + (tx.trim().length ? tx : "");

  const name = extractNameFromText(src) || patientName || "";
  const phn = extractPHNFromText(src) || patientPHN || "";
  const ageDisp = extractAgeDisplay(src) || (patientAge ? `${patientAge} years` : "");
  const genderRaw = extractGenderFromText(src) || "";
  const gender = genderRaw === "M" ? "Male" : (genderRaw === "F" ? "Female" : genderRaw);

  const famNames = extractFamilyMembersNames(src);
  const occ = extractOccupation(src);
  const hobbies = extractHobbies(src);
  const social = extractRecentSocialLife(src);

  const sections = [];
  sections.push([
    `Patient Name: ${name || "â€”"}`,
    `PHN: ${phn || "â€”"}`,
    `Age: ${ageDisp || "â€”"}`,
    `Gender: ${gender || "â€”"}`,
  ].join("\n"));

  if (famNames) sections.push(`Family members names: ${famNames}`);

  const socialLines = [];
  if (occ) socialLines.push(`Occupation: ${occ}`);
  if (hobbies) socialLines.push(`Hobbies and interests: ${hobbies}`);
  if (social) socialLines.push(`Recent social life: ${social}`);
  if (socialLines.length) sections.push(socialLines.join("\n"));

  return sections.join("\n\n").trimEnd();
}

function normalizeSummaryArray(v) {
  if (Array.isArray(v)) return v.map(x => String(x || "").trim()).filter(Boolean);
  if (typeof v === "string") {
    return v.split(/\n+/).map(x => String(x || "").trim()).filter(Boolean);
  }
  return [];
}
function renderSummaryList(items, emptyText="â€”") {
  const clean = normalizeSummaryArray(items);
  if (!clean.length) return `<div class="summary-line">${escapeHtml(emptyText)}</div>`;
  return `<ul class="summary-list">${clean.map(i => `<li>${escapeHtml(i)}</li>`).join("")}</ul>`;
}
function renderPatientSummaryAI(summary) {
  const s = (summary && typeof summary === "object") ? summary : {};
  const name = String(s.patient_name || "").trim();
  const phn = String(s.phn || "").trim();
  const age = String(s.age_display || "").trim();
  const gender = String(s.gender || "").trim();
  const family = String(s.family_members || "").trim();
  const occupation = String(s.occupation || "").trim();
  const hobbies = String(s.hobbies_and_interests || "").trim();
  const social = String(s.recent_social_life || "").trim();

  const lastVisits = normalizeSummaryArray(s.recent_visits);
  const lifeEvents = normalizeSummaryArray(s.significant_life_events);
  const diagnoses = normalizeSummaryArray(s.diagnoses);

  const currentYear = new Date().getFullYear();
  const hasRecentVisit = (() => {
    if (!lastVisits.length) return false;
    const years = lastVisits
      .map(v => {
        const m = String(v).match(/\b(20\d{2})\b/);
        return m ? parseInt(m[1], 10) : null;
      })
      .filter(v => Number.isFinite(v));
    if (!years.length) return true;
    return years.some(y => y >= currentYear - 1);
  })();

  const parts = [];

  parts.push(
    `<div class="summary-section">` +
      `<div class="summary-line"><span class="summary-label">Patient Name:</span> ${escapeHtml(name || "â€”")}</div>` +
      `<div class="summary-line"><span class="summary-label">PHN:</span> ${escapeHtml(phn || "â€”")}</div>` +
      `<div class="summary-line"><span class="summary-label">Age:</span> ${escapeHtml(age || "â€”")}</div>` +
      `<div class="summary-line"><span class="summary-label">Gender:</span> ${escapeHtml(gender || "â€”")}</div>` +
    `</div>`
  );

  if (family) {
    parts.push(
      `<div class="summary-section">` +
        `<div class="summary-line"><span class="summary-label">Family members names:</span> ${escapeHtml(family)}</div>` +
      `</div>`
    );
  }

  const socialLines = [];
  if (occupation) socialLines.push(`<div class="summary-line"><span class="summary-label">Occupation:</span> ${escapeHtml(occupation)}</div>`);
  if (hobbies) socialLines.push(`<div class="summary-line"><span class="summary-label">Hobbies and interests:</span> ${escapeHtml(hobbies)}</div>`);
  if (social) socialLines.push(`<div class="summary-line"><span class="summary-label">Recent social life:</span> ${escapeHtml(social)}</div>`);
  if (socialLines.length) {
    parts.push(`<div class="summary-section">${socialLines.join("")}</div>`);
  }

  if (hasRecentVisit) {
    parts.push(
      `<div class="summary-section">` +
        `<div class="summary-title">Recent visits:</div>` +
        `${renderSummaryList(lastVisits)}` +
      `</div>`
    );
  }

  if (lifeEvents.length) {
    parts.push(
      `<div class="summary-section">` +
        `<div class="summary-title">Significant Life Events:</div>` +
        `${renderSummaryList(lifeEvents)}` +
      `</div>`
    );
  }

  if (diagnoses.length) {
    parts.push(
      `<div class="summary-section">` +
        `<div class="summary-title">Diagnoses:</div>` +
        `${renderSummaryList(diagnoses)}` +
      `</div>`
    );
  }

  snapshotPanel.classList.add("summary-view");
  snapshotPanel.innerHTML = parts.join("").trim();
  hasAiSummary = true;
  markUpdated("snapshot");
}

function renderRapidSummary(force=false) {
  if (!force && hasAiSummary) return;
  snapshotPanel.classList.remove("summary-view");
  const snap = buildPatientSummaryText(emrBackgroundText, transcriptBox.value || "");
  snapshotPanel.textContent = snap;
  lastSnapshotHash = hashLite(snap);
  markUpdated("snapshot");
}

async function loadPatientSummaryAI(force=false) {
  const emr = (emrBackgroundText || "").trim();
  if (!emr) return;
  const h = hashLite(emr);
  if (!force && h === lastPatientSummaryHash) return;
  if (patientSummaryBusy) return;

  patientSummaryBusy = true;
  lastPatientSummaryHash = h;
  try {
    await ensureSession();
    const data = await apiPost(`/session/${sessionId}/patient_summary`);
    const summary = (data && data.summary) ? data.summary : data;
    const hasText = (v) => String(v || "").trim().length > 0;
    const hasArr = (v) => Array.isArray(v) && v.length > 0;
    const hasDetails = summary && typeof summary === "object" && (
      hasText(summary.family_members) ||
      hasText(summary.occupation) ||
      hasText(summary.hobbies_and_interests) ||
      hasText(summary.recent_social_life) ||
      hasArr(summary.recent_visits) ||
      hasArr(summary.significant_life_events) ||
      hasArr(summary.diagnoses)
    );
    if (!hasDetails) {
      lastPatientSummaryHash = "";
      return;
    }
    renderPatientSummaryAI(summary);
  } catch (err) {
    hasAiSummary = false;
    uiError("Patient Summary", err);
  } finally {
    patientSummaryBusy = false;
  }
}

// -------------------------
// Chat message rendering
// -------------------------
function addMessage(role, text) {
  const r = String(role || "").toLowerCase();
  const kind =
    (r === "you" || r === "user") ? "user" :
    (r === "system") ? "system" :
    "assistant";

  const row = document.createElement("div");
  row.className = `msg ${kind}`;

  const bubble = document.createElement("div");
  bubble.className = "bubble";

  if (kind !== "system") {
    const meta = document.createElement("div");
    meta.className = "bubble-meta";
    meta.textContent = (kind === "user") ? "You" : "Centaur";
    bubble.appendChild(meta);
  }

  const content = document.createElement("div");
  const textStr = asText(text);

  if (kind === "assistant") {
    const clean = stripPairedMarkdownEmphasis(textStr);
    content.innerHTML = safeSubsetFormat(clean);
  } else {
    content.textContent = textStr;
  }
  bubble.appendChild(content);
  row.appendChild(bubble);
  const shouldScroll = isNearBottom(chatLog);
  chatLog.appendChild(row);
  if (shouldScroll) chatLog.scrollTop = chatLog.scrollHeight;

  if (kind === "assistant") {
    lastAssistantPlainText = stripPairedMarkdownEmphasis(textStr);
  }
  return content;
}
function logChat(role, text) { addMessage(role, text); }

function scrollChatToMessageStart(contentEl) {
  if (!chatLog || !contentEl) return;
  const row = contentEl.closest(".msg");
  if (!row) return;
  const top = row.offsetTop || 0;
  chatLog.scrollTop = Math.max(0, top);
  chatAutoScroll = false;
}

function hashLite(text) {
  const s = String(text || "");
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return (h >>> 0).toString(16);
}

function extractClinicalQueryText() {
  const rows = Array.from(chatLog?.querySelectorAll(".msg") || []);
  const parts = [];
  for (const row of rows) {
    const role =
      row.classList.contains("user") ? "You" :
      row.classList.contains("system") ? "System" :
      "Centaur";
    if (role === "System") continue;
    const bubble = row.querySelector(".bubble");
    if (!bubble) continue;
    const contentEl = bubble.lastElementChild;
    const text = (contentEl?.textContent || "").trim();
    if (!text) continue;
    parts.push(`${role}: ${text}`);
  }
  return parts.join("\n\n").trim();
}

function hasCurrentPatientData() {
  const hasTranscript = (transcriptBox?.value || "").trim().length > 0;
  const hasEmr = (emrBackgroundText || "").trim().length > 0;
  const hasChat = (chatLog?.querySelectorAll(".msg.user, .msg.assistant") || []).length > 0;
  return hasTranscript || hasEmr || hasChat;
}

async function copyFullContextToClipboard() {
  const transcript = (transcriptBox?.value || "").trim();
  const emr = (emrBackgroundText || "").trim();
  const chat = extractClinicalQueryText();
  const blocks = [];
  if (transcript) blocks.push(transcript);
  if (emr) blocks.push(`EMR Dump:\n${emr}`);
  if (chat) blocks.push(`Clinical Query:\n${chat}`);
  const fullText = blocks.join("\n\n").trim();
  if (!fullText) {
    logChat("System", "Nothing to copy yet.");
    return;
  }
  try {
    await navigator.clipboard.writeText(fullText);
  } catch {
    await copyRichText(fullText);
  }
  logChat("System", "Full context copied to clipboard.");
}

function isNearBottom(el, threshold=140) {
  if (!el) return true;
  const gap = el.scrollHeight - el.scrollTop - el.clientHeight;
  return gap < threshold;
}

let chatAutoScroll = true;
chatLog.addEventListener("scroll", () => {
  chatAutoScroll = isNearBottom(chatLog);
});

function looksLikeEmrPaste(text) {
  const t = (text || "").trim();
  if (t.length < 240) return false;
  const tl = t.toLowerCase();
  const lineCount = t.split(/\n/).filter(l => l.trim()).length;

  const phnHit = /(?:^|\n)\s*(?:phn|uli|personal health number)\b/i.test(t) || /\b\d{9,10}\s*\|\s*ab\b/i.test(t);
  const demoHit = /\b(dob|date of birth|age|yr old|years old|sex|gender|mrn|address|postal|phone)\b/i.test(t);
  const uiHit = /\b(dashboard|scheduler|bills|tasks|consults|patient notes|vitals|patient lists|ava connect|health profile|clinical notes)\b/i.test(tl);

  const sections = [
    "medications", "allerg", "problem list", "diagnos", "assessment", "plan",
    "subjective", "objective", "family hx", "social history", "immun", "vaccin",
    "labs", "investigations", "imaging", "consults", "notes"
  ];
  let sectionHits = 0;
  for (const k of sections) {
    if (tl.includes(k)) sectionHits += 1;
  }

  const dateLines = (t.match(/^\s*\d{4}[-/](?:\d{1,2}|[A-Za-z]{3,9})[-/]\d{1,2}\b/gm) || []).length;
  const imagingReport = /\b(impression|findings|technique|comparison|exam|clinical (history|indication)|indication)\s*:/i.test(t);

  let score = 0;
  if (phnHit) score += 3;
  if (uiHit) score += 3;
  if (demoHit) score += 1;
  if (sectionHits >= 3) score += 3;
  else if (sectionHits >= 2) score += 2;
  else if (sectionHits === 1) score += 1;
  if (dateLines >= 2) score += 1;
  if (lineCount >= 12) score += 1;

  if (imagingReport && score < 4) return false;
  return score >= 4;
}

// -------------------------
// Auth
// -------------------------
function authHeaders() {
  return authToken ? { "Authorization": `Bearer ${authToken}` } : {};
}
function setAuthToken(token) {
  authToken = String(token || "");
  if (authToken) localStorage.setItem(AUTH_TOKEN_KEY, authToken);
  else localStorage.removeItem(AUTH_TOKEN_KEY);
}
function clearAuthToken() {
  setAuthToken("");
  authUser = null;
  setAdminUIVisibility();
}
function showAuthError(msg) {
  if (!authError) return;
  authError.textContent = msg || "Login failed.";
  authError.style.display = msg ? "block" : "none";
}
function setAuthMode(mode) {
  const isLogin = mode === "login";
  authTabLogin?.classList.toggle("active", isLogin);
  authTabSignup?.classList.toggle("active", !isLogin);
  authLoginForm?.classList.toggle("active", isLogin);
  authSignupForm?.classList.toggle("active", !isLogin);
  showAuthError("");
  if (isLogin) authLoginUsername?.focus();
  else authSignupUsername?.focus();
}
function showAuthOverlay(mode="login") {
  if (authOverlay) authOverlay.style.display = "flex";
  setAuthMode(mode);
}
function hideAuthOverlay() {
  if (authOverlay) authOverlay.style.display = "none";
  showAuthError("");
}
function handleAuthRequired() {
  clearAuthToken();
  showAuthOverlay("login");
}

function openNewPatientConfirm() {
  if (!newPatientConfirmOverlay || !newPatientConfirmPanel) return;
  newPatientConfirmOverlay.style.display = "block";
  newPatientConfirmPanel.style.display = "flex";
}

function closeNewPatientConfirm() {
  if (!newPatientConfirmOverlay || !newPatientConfirmPanel) return;
  newPatientConfirmOverlay.style.display = "none";
  newPatientConfirmPanel.style.display = "none";
}

async function startNewPatientSession() {
  try {
    stopRecording();
  } catch {}
  recState = "idle";

  transcriptBox.value = "";
  chatLog.innerHTML = "";
  snapshotPanel.textContent = "";
  coachPanel.textContent = "";

  panelUpdatedAt.snapshot = 0;
  panelUpdatedAt.coach = 0;
  panelUpdatedAt.transcript = 0;

  lastSnapshotHash = "";
  lastPatientSummaryHash = "";
  hasAiSummary = false;
  patientSummaryBusy = false;
  lastCoachHash = "";
  emrBackgroundText = "";
  lastCoachRunAt = 0;
  coachPendingChars = 0;
  coachPendingWords = 0;
  lastAssistantPlainText = "";
  hasBilledCurrentPatient = false;

  patientName = "";
  patientPHN = "";
  patientAge = "";

  await createSession();
  logChat("System", "New patient session created.");
}
async function ensureAuth() {
  if (!authToken) {
    showAuthOverlay("login");
    return false;
  }
  try {
    const me = await apiGet("/auth/me");
    authUser = me?.user || null;
    if (!authUser) throw new Error("No user.");
    setAdminUIVisibility();
    hideAuthOverlay();
    return true;
  } catch {
    handleAuthRequired();
    return false;
  }
}
async function bootstrapApp() {
  if (appBootstrapped) return;
  appBootstrapped = true;

  await createSession();
  renderDraft();
  await initMacros();
  setRecordingUI(false);

  snapshotPanel.textContent = snapshotPanel.textContent || "";
  coachPanel.textContent = coachPanel.textContent || "";

  await loadBillingFromServer();

  logChat("System", "Centaur Web ready.");
}

// -------------------------
// API wrappers
// -------------------------
async function apiGet(path) {
  const res = await fetchWithTimeout(`${API_BASE}${path}`, { method: "GET", headers: { ...authHeaders() } });
  if (res.status === 401) {
    handleAuthRequired();
    throw new Error("401 Unauthorized");
  }
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
  return await res.json();
}
async function apiPost(path, bodyObj) {
  const hasBody = !(bodyObj === undefined || bodyObj === null);
  const opts = { method: "POST" };
  if (hasBody) {
    opts.headers = { "Content-Type": "application/json", ...authHeaders() };
    opts.body = JSON.stringify(bodyObj);
  } else {
    opts.headers = { ...authHeaders() };
  }
  const res = await fetchWithTimeout(`${API_BASE}${path}`, opts);
  if (res.status === 401) {
    handleAuthRequired();
    throw new Error("401 Unauthorized");
  }
  if (!res.ok) {
    let detail = "";
    try {
      const j = await res.json();
      detail = j?.detail ? ` â€” ${j.detail}` : ` â€” ${safeJsonStringify(j)}`;
    } catch {
      try {
        const t = await res.text();
        detail = t ? ` â€” ${t}` : "";
      } catch {}
    }
    throw new Error(`${res.status} ${res.statusText}${detail}`);
  }
  const txt = await res.text();
  if (!txt) return {};
  try { return JSON.parse(txt); } catch { return { raw: txt }; }
}
async function apiPut(path, bodyObj) {
  const hasBody = !(bodyObj === undefined || bodyObj === null);
  const opts = { method: "PUT" };
  if (hasBody) {
    opts.headers = { "Content-Type": "application/json", ...authHeaders() };
    opts.body = JSON.stringify(bodyObj);
  } else {
    opts.headers = { ...authHeaders() };
  }
  const res = await fetchWithTimeout(`${API_BASE}${path}`, opts);
  if (res.status === 401) {
    handleAuthRequired();
    throw new Error("401 Unauthorized");
  }
  if (!res.ok) {
    let detail = "";
    try {
      const j = await res.json();
      detail = j?.detail ? ` â€” ${j.detail}` : ` â€” ${safeJsonStringify(j)}`;
    } catch {
      try {
        const t = await res.text();
        detail = t ? ` â€” ${t}` : "";
      } catch {}
    }
    throw new Error(`${res.status} ${res.statusText}${detail}`);
  }
  const txt = await res.text();
  if (!txt) return {};
  try { return JSON.parse(txt); } catch { return { raw: txt }; }
}
async function apiPostStreamNDJSON(path, bodyObj, onChunk) {
  const hasBody = !(bodyObj === undefined || bodyObj === null);
  const opts = { method: "POST" };
  if (hasBody) {
    opts.headers = { "Content-Type": "application/json", ...authHeaders() };
    opts.body = JSON.stringify(bodyObj);
  } else {
    opts.headers = { ...authHeaders() };
  }
  const res = await fetchWithTimeout(`${API_BASE}${path}`, opts);
  if (res.status === 401) {
    handleAuthRequired();
    throw new Error("401 Unauthorized");
  }
  if (!res.ok) {
    let detail = "";
    try {
      const j = await res.json();
      detail = j?.detail ? ` â€” ${j.detail}` : ` â€” ${safeJsonStringify(j)}`;
    } catch {
      try {
        const t = await res.text();
        detail = t ? ` â€” ${t}` : "";
      } catch {}
    }
    throw new Error(`${res.status} ${res.statusText}${detail}`);
  }
  if (!res.body) throw new Error("Streaming not supported by browser.");

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let meta = null;

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });
    let idx;
    while ((idx = buffer.indexOf("\n")) >= 0) {
      const line = buffer.slice(0, idx).trim();
      buffer = buffer.slice(idx + 1);
      if (!line) continue;
      let msg = null;
      try { msg = JSON.parse(line); } catch { msg = null; }
      if (!msg || typeof msg !== "object") continue;
      if (msg.type === "chunk") {
        const data = (msg.data || "");
        if (data) onChunk(String(data));
      } else if (msg.type === "meta") {
        meta = msg.data || {};
      } else if (msg.type === "error") {
        throw new Error(String(msg.data || "Stream error"));
      }
    }
  }

  return meta || {};
}
async function apiDelete(path) {
  const res = await fetchWithTimeout(`${API_BASE}${path}`, { method: "DELETE", headers: { ...authHeaders() } });
  if (res.status === 401) {
    handleAuthRequired();
    throw new Error("401 Unauthorized");
  }
  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`${res.status} ${res.statusText}${t ? " â€” " + t : ""}`);
  }
  const txt = await res.text();
  if (!txt) return {};
  try { return JSON.parse(txt); } catch { return { raw: txt }; }
}

// -------------------------
// Session lifecycle
// -------------------------
async function createSession() {
  const data = await apiPost("/session/create"); // no body
  sessionId = data.session_id;
  console.log("Session created:", sessionId);
  if (ambientController) ambientController.setSession(sessionId);
  return sessionId;
}
async function ensureSession() { if (!sessionId) await createSession(); }

// -------------------------
// Audio transcription
// -------------------------
async function getPreferredAudioStream() {
  if (!navigator.mediaDevices?.getUserMedia) throw new Error("Audio capture not supported.");
  const constraints = {
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
    }
  };
  try {
    return await navigator.mediaDevices.getUserMedia(constraints);
  } catch {
    return await navigator.mediaDevices.getUserMedia({ audio: true });
  }
}
async function requestMicrophonePermission() {
  try {
    const stream = await getPreferredAudioStream();
    if (!audioStream) {
      audioStream = stream;
    } else {
      try { stream.getTracks().forEach(t => t.stop()); } catch {}
    }
    return true;
  } catch (err) {
    console.warn("Mic permission denied or blocked:", err);
    return false;
  }
}
function activateAudioStream(stream) {
  if (!stream) return;
  try { stream.getTracks().forEach(t => { t.enabled = true; }); } catch {}
}
function deactivateAudioStream(stream) {
  if (!stream) return;
  try { stream.getTracks().forEach(t => { t.enabled = false; }); } catch {}
}
function releaseAudioStream() {
  try { audioStream?.getTracks().forEach(t => t.stop()); } catch {}
  audioStream = null;
}
async function getOrCreateAudioStream() {
  if (audioStream) {
    const track = audioStream.getAudioTracks?.()[0];
    if (track && track.readyState === "live") {
      return audioStream;
    }
  }
  return await getPreferredAudioStream();
}

let micPrimed = false;
function primeMicOnFirstUserGesture() {
  if (micPrimed) return;
  micPrimed = true;
  const handler = async () => {
    document.removeEventListener("pointerdown", handler);
    document.removeEventListener("keydown", handler);
    try { await requestMicrophonePermission(); } catch {}
    try {
      if (!ambientController) ambientController = new AmbientController();
      if (!ambientController.enabled || ambientController.error) {
        await setAmbientEnabled(true);
      } else if (ambientController.paused) {
        await ambientController.resume();
      }
    } catch {}
  };
  document.addEventListener("pointerdown", handler, { once: true });
  document.addEventListener("keydown", handler, { once: true });
}

function pickBestMime() {
  const candidates = [
    { mime: "audio/webm;codecs=opus", ext: "webm" },
    { mime: "audio/webm", ext: "webm" },
    { mime: "audio/ogg;codecs=opus", ext: "ogg" },
    { mime: "audio/ogg", ext: "ogg" },
    { mime: "audio/mp4", ext: "mp4" },
  ];
  for (const c of candidates) {
    if (window.MediaRecorder && MediaRecorder.isTypeSupported(c.mime)) return c;
  }
  return { mime: "", ext: "webm" };
}
async function uploadAudioBlob(blob, stats=null) {
  if (!blob || blob.size < 3000) return;
  if (shouldDropChunk(stats)) return;
  const fd = new FormData();
  const filename = `chunk_${Date.now()}.${chosenExt}`;
  fd.append("file", blob, filename);

  const res = await fetchWithTimeout(`${API_BASE}/transcribe_chunk?session_id=${sessionId}`, {
    method: "POST",
    body: fd,
    headers: { ...authHeaders() }
  });

  if (!res.ok) {
    const t = await res.text().catch(() => "");
    throw new Error(`Transcribe failed: ${res.status} ${res.statusText} â€” ${t}`);
  }
  const data = await res.json();
  const text = (data?.text || "").trim();
  if (text && !isGarbageDelta(text)) {
    transcriptBox.value += (transcriptBox.value ? " " : "") + text;
    transcriptBox.scrollTop = transcriptBox.scrollHeight;
    registerTranscriptDelta(text, { utteranceEnded: true });
    setPatientAnchorFromTextBestEffort(text);
    panelUpdatedAt.transcript = Date.now();

    if ((emrBackgroundText || "").trim().length) {
      renderRapidSummary();
      refreshPatientAnchorFromSnapshotPreferred();
    }
  }
}
function scheduleChunkStop() {
  clearTimeout(chunkStopTimeout);
  chunkStopTimeout = setTimeout(() => {
    try { if (recorder && recorder.state === "recording") recorder.stop(); } catch {}
  }, CHUNK_MS);
}
async function startRecording() {
  try {
    await ensureSession();
    const pick = pickBestMime();
    chosenMime = pick.mime;
    chosenExt = pick.ext;

    audioStream = await getOrCreateAudioStream();
    activateAudioStream(audioStream);
    isRecording = true;
    recState = "recording";
    setRecordingUI(true);
    startTimer();
    await startMicViz(audioStream);
    await requestWakeLock();

    const startNextChunk = () => {
      if (!isRecording) return;
      const chunks = [];
      const options = {};
      if (chosenMime) options.mimeType = chosenMime;

      const chunkStartedAt = performance.now();
      recorder = new MediaRecorder(audioStream, options);

      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };
      recorder.onstop = async () => {
        try {
          const blob = new Blob(chunks, { type: chosenMime || undefined });
          const chunkEndedAt = performance.now();
          const stats = analyzeChunkAudioStats(chunkStartedAt, chunkEndedAt);
          await uploadAudioBlob(blob, stats);
        } catch (err) {
          console.error("Transcription error:", err);
        } finally {
          if (isRecording) startNextChunk();
        }
      };

      recorder.start();
      scheduleChunkStop();
    };

    startNextChunk();
  } catch (err) {
    uiError("Start recording", err);
    recState = "idle";
    isRecording = false;
    try { if (recorder && recorder.state !== "inactive") recorder.stop(); } catch {}
    releaseAudioStream();
    recorder = null;
    stopMicViz();
    setRecordingUI(false);
  }
}
function stopRecording(releaseStream=false) {
  isRecording = false;
  recState = "paused";
  clearTimeout(chunkStopTimeout);
  try { if (recorder && recorder.state !== "inactive") recorder.stop(); } catch {}
  if (releaseStream) releaseAudioStream();
  else deactivateAudioStream(audioStream);
  recorder = null;
  setRecordingUI(false);
  stopTimer();
  stopMicViz();
  releaseWakeLock();
}

// -------------------------
// Ambient Mode
// -------------------------
class Float32RingBuffer {
  constructor(maxSamples) {
    this.maxSamples = maxSamples;
    this.buffer = new Float32Array(maxSamples);
    this.writeIndex = 0;
    this.size = 0;
  }
  push(samples) {
    if (!samples || !samples.length) return;
    const len = samples.length;
    for (let i = 0; i < len; i++) {
      this.buffer[this.writeIndex] = samples[i];
      this.writeIndex = (this.writeIndex + 1) % this.maxSamples;
      if (this.size < this.maxSamples) this.size += 1;
    }
  }
  readLast(sampleCount) {
    const count = Math.min(sampleCount, this.size);
    if (count <= 0) return new Float32Array(0);
    const out = new Float32Array(count);
    let idx = (this.writeIndex - count + this.maxSamples) % this.maxSamples;
    for (let i = 0; i < count; i++) {
      out[i] = this.buffer[(idx + i) % this.maxSamples];
    }
    return out;
  }
  clear() {
    this.writeIndex = 0;
    this.size = 0;
  }
}

function makeId() {
  if (crypto?.randomUUID) return crypto.randomUUID();
  return `seg_${Date.now()}_${Math.random().toString(16).slice(2)}`;
}

function downsampleBuffer(buffer, sampleRate, targetRate) {
  if (targetRate === sampleRate) return buffer;
  const ratio = sampleRate / targetRate;
  const newLen = Math.round(buffer.length / ratio);
  const result = new Float32Array(newLen);
  let offsetResult = 0;
  let offsetBuffer = 0;
  while (offsetResult < result.length) {
    const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
    let sum = 0;
    let count = 0;
    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
      sum += buffer[i];
      count += 1;
    }
    result[offsetResult] = count ? (sum / count) : 0;
    offsetResult += 1;
    offsetBuffer = nextOffsetBuffer;
  }
  return result;
}

function encodeWav(samples, sampleRate, targetRate=16000) {
  const pcm = downsampleBuffer(samples, sampleRate, targetRate);
  const buffer = new ArrayBuffer(44 + pcm.length * 2);
  const view = new DataView(buffer);
  const writeString = (offset, str) => {
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  };
  writeString(0, "RIFF");
  view.setUint32(4, 36 + pcm.length * 2, true);
  writeString(8, "WAVE");
  writeString(12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, targetRate, true);
  view.setUint32(28, targetRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(36, "data");
  view.setUint32(40, pcm.length * 2, true);
  let offset = 44;
  for (let i = 0; i < pcm.length; i++) {
    let s = Math.max(-1, Math.min(1, pcm[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
    offset += 2;
  }
  return new Blob([buffer], { type: "audio/wav" });
}

class AmbientController {
  constructor() {
    this.enabled = false;
    this.paused = false;
    this.error = false;
    this.encounterId = "";
    this.sessionId = "";
    this.audioContext = null;
    this.processor = null;
    this.source = null;
    this.gainNode = null;
    this.sampleRate = 48000;
    this.ringBuffer = null;
    this.queue = [];
    this.inFlight = 0;
    this.maxInFlight = 1;
    this.maxQueue = 3;
    this.noiseFloor = 0.003;
    this.vadFloor = 0.004;
    this.vadMultiplier = 1.8;
    this.vadState = "silence";
    this.speechMs = 0;
    this.silenceMs = 0;
    this.postRollRemaining = 0;
    this.currentChunks = [];
    this.currentSegmentMs = 0;
    this.segmentStartMs = 0;
    this.preRollMs = 500;
    this.postRollMs = 800;
    this.maxSegmentMs = 12000;
    this.minSegmentMs = 500;
    this.ringBufferSeconds = 120;
  }

  setSession(sessionId) {
    if (this.sessionId && this.sessionId !== sessionId) {
      this.stopEncounter();
      this.clearBuffer();
    }
    this.sessionId = sessionId || "";
    this.encounterId = "";
    if (this.enabled && !this.paused) {
      this.startEncounter();
    }
    this.updateStatus();
  }

  async enable() {
    if (this.enabled) return;
    this.enabled = true;
    this.paused = false;
    this.error = false;
    await this.startMic();
    await this.startEncounter();
    await requestWakeLock();
    this.updateStatus();
  }

  async disable() {
    if (!this.enabled) return;
    await this.stopEncounter();
    this.clearBuffer();
    this.stopMic();
    this.enabled = false;
    this.paused = false;
    releaseWakeLock();
    this.updateStatus();
  }

  async startMic() {
    await ensureSession();
    audioStream = await getOrCreateAudioStream();
    activateAudioStream(audioStream);
    if (!this.audioContext) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioCtx();
      this.sampleRate = this.audioContext.sampleRate;
      this.ringBuffer = new Float32RingBuffer(this.sampleRate * this.ringBufferSeconds);
      this.source = this.audioContext.createMediaStreamSource(audioStream);
      this.processor = this.audioContext.createScriptProcessor(2048, 1, 1);
      this.gainNode = this.audioContext.createGain();
      this.gainNode.gain.value = 0;
      this.source.connect(this.processor);
      this.processor.connect(this.gainNode);
      this.gainNode.connect(this.audioContext.destination);
      try {
        if (this.audioContext.state === "suspended") {
          await this.audioContext.resume();
        }
      } catch (err) {
        console.warn("AudioContext resume blocked:", err);
      }
      this.processor.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        this.handleAudioFrame(input);
      };
    }
    if (this.audioContext && this.audioContext.state === "suspended") {
      throw new Error("AudioContext suspended");
    }
  }

  stopMic() {
    try { this.processor?.disconnect(); } catch {}
    try { this.source?.disconnect(); } catch {}
    try { this.gainNode?.disconnect(); } catch {}
    this.processor = null;
    this.source = null;
    this.gainNode = null;
    try { this.audioContext?.close(); } catch {}
    this.audioContext = null;
    deactivateAudioStream(audioStream);
  }

  async startEncounter() {
    if (!this.sessionId) await ensureSession();
    if (this.encounterId) return;
    const payload = { session_id: this.sessionId, consent_confirmed: true };
    const data = await apiPost("/ambient/start_encounter", payload);
    this.encounterId = data?.encounter_id || "";
  }

  async stopEncounter() {
    if (!this.encounterId || !this.sessionId) return;
    try {
      await apiPost("/ambient/stop_encounter", {
        session_id: this.sessionId,
        encounter_id: this.encounterId,
      });
    } catch {}
    this.encounterId = "";
    this.updateStatus();
  }

  pause() {
    this.paused = true;
    this.stopMic();
    releaseWakeLock();
    this.updateStatus();
  }

  async resume() {
    this.paused = false;
    if (this.audioContext && this.audioContext.state === "suspended") {
      try { await this.audioContext.resume(); } catch {}
    }
    await this.startMic();
    if (!this.encounterId) await this.startEncounter();
    await requestWakeLock();
    this.updateStatus();
    this.processQueue();
  }

  clearBuffer() {
    this.ringBuffer?.clear();
    this.queue = [];
    this.currentChunks = [];
    this.currentSegmentMs = 0;
    this.segmentStartMs = 0;
    this.vadState = "silence";
    this.speechMs = 0;
    this.silenceMs = 0;
    this.postRollRemaining = 0;
    this.updateStatus();
  }

  handleAudioFrame(input) {
    if (!this.enabled || this.paused) return;
    if (!input || !input.length) return;
    this.ringBuffer?.push(input);
    const frameMs = (input.length / this.sampleRate) * 1000;
    const rms = Math.sqrt(input.reduce((sum, v) => sum + v * v, 0) / input.length);
    this.noiseFloor = (this.noiseFloor * 0.95) + (rms * 0.05);
    const threshold = Math.max(this.vadFloor, this.noiseFloor * this.vadMultiplier);
    const isVoice = rms > threshold;

    if (this.vadState === "silence") {
      if (isVoice) {
        this.speechMs += frameMs;
        if (this.speechMs >= 200) {
          this.startSpeechSegment();
          this.vadState = "speech";
          this.speechMs = 0;
        }
      } else {
        this.speechMs = 0;
      }
    } else if (this.vadState === "speech") {
      this.appendToSegment(input, frameMs);
      if (!isVoice) {
        this.silenceMs += frameMs;
        if (this.silenceMs >= 500) {
          this.vadState = "postroll";
          this.postRollRemaining = this.postRollMs;
        }
      } else {
        this.silenceMs = 0;
      }

      if (this.currentSegmentMs >= this.maxSegmentMs) {
        this.finalizeSegment();
        this.startSpeechSegment(false);
        this.vadState = "speech";
      }
    } else if (this.vadState === "postroll") {
      this.appendToSegment(input, frameMs);
      this.postRollRemaining -= frameMs;
      if (this.postRollRemaining <= 0) {
        this.finalizeSegment();
        this.vadState = "silence";
      }
    }
  }

  startSpeechSegment(includePreRoll=true) {
    this.currentChunks = [];
    this.currentSegmentMs = 0;
    this.segmentStartMs = Date.now();
    if (includePreRoll && this.ringBuffer) {
      const preSamples = this.ringBuffer.readLast(Math.round(this.sampleRate * (this.preRollMs / 1000)));
      if (preSamples.length) {
        this.currentChunks.push(preSamples);
        this.currentSegmentMs += (preSamples.length / this.sampleRate) * 1000;
        this.segmentStartMs -= this.preRollMs;
      }
    }
  }

  appendToSegment(samples, frameMs) {
    if (!samples || !samples.length) return;
    this.currentChunks.push(new Float32Array(samples));
    this.currentSegmentMs += frameMs;
  }

  finalizeSegment() {
    if (this.currentSegmentMs < this.minSegmentMs) {
      this.currentChunks = [];
      this.currentSegmentMs = 0;
      return;
    }
    const totalLen = this.currentChunks.reduce((sum, arr) => sum + arr.length, 0);
    const merged = new Float32Array(totalLen);
    let offset = 0;
    for (const chunk of this.currentChunks) {
      merged.set(chunk, offset);
      offset += chunk.length;
    }
    const blob = encodeWav(merged, this.sampleRate, 16000);
    const now = Date.now();
    const segment = {
      id: makeId(),
      blob,
      startMs: this.segmentStartMs,
      endMs: now,
      retries: 0,
    };
    this.enqueueSegment(segment);
    this.currentChunks = [];
    this.currentSegmentMs = 0;
  }

  enqueueSegment(segment) {
    if (this.queue.length >= this.maxQueue) {
      if (!navigator.onLine) {
        this.pause();
        showToast("Offline. Ambient capture paused; queue full.", "warn");
        return;
      }
      this.queue.shift();
      showToast("Ambient queue full; dropping oldest segment.", "warn");
    }
    this.queue.push(segment);
    this.processQueue();
    this.updateStatus();
  }

  updateStatus() {
    if (!this.enabled) {
      updateAmbientUI(this.error ? "error" : "initializing");
      return;
    }
    if (!navigator.onLine) {
      updateAmbientUI("offline");
      return;
    }
    if (this.paused) {
      updateAmbientUI("paused");
      return;
    }
    updateAmbientUI("listening");
  }

  async processQueue() {
    if (!this.enabled || this.paused) return;
    if (!navigator.onLine) {
      this.updateStatus();
      return;
    }
    if (this.inFlight >= this.maxInFlight) return;
    if (!this.encounterId) return;
    const next = this.queue.shift();
    if (!next) return;
    this.inFlight += 1;
    this.updateStatus();
    try {
      const fd = new FormData();
      fd.append("session_id", this.sessionId);
      fd.append("encounter_id", this.encounterId);
      fd.append("segment_id", next.id);
      fd.append("start_ts", new Date(next.startMs).toISOString());
      fd.append("end_ts", new Date(next.endMs).toISOString());
      fd.append("file", next.blob, `${next.id}.wav`);
      const res = await fetchWithTimeout(`${API_BASE}/ambient/upload_segment`, {
        method: "POST",
        body: fd,
        headers: { ...authHeaders() },
      });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`${res.status} ${res.statusText}${t ? " â€” " + t : ""}`);
      }
      const data = await res.json();
      const text = (data?.text || "").trim();
      if (text && !isGarbageDelta(text)) {
        transcriptBox.value += (transcriptBox.value ? "\n" : "") + text;
        transcriptBox.scrollTop = transcriptBox.scrollHeight;
        registerTranscriptDelta(text, { utteranceEnded: true });
        setPatientAnchorFromTextBestEffort(text);
        panelUpdatedAt.transcript = Date.now();
        if ((emrBackgroundText || "").trim().length) {
          renderRapidSummary();
          refreshPatientAnchorFromSnapshotPreferred();
        }
      }
    } catch (err) {
      next.retries += 1;
      const delay = Math.min(8000, 500 * Math.pow(2, next.retries));
      this.queue.unshift(next);
      setTimeout(() => this.processQueue(), delay);
    } finally {
      this.inFlight = Math.max(0, this.inFlight - 1);
      this.updateStatus();
      if (this.queue.length) this.processQueue();
    }
  }
}

async function setAmbientEnabled(enabled) {
  ambientEnabled = Boolean(enabled);
  if (!ambientController) ambientController = new AmbientController();
  try {
    if (ambientEnabled) await ambientController.enable();
    else await ambientController.disable();
  } catch (err) {
    ambientEnabled = false;
    if (ambientController) ambientController.error = true;
    await ambientController.disable();
    showToast("Ambient mode could not start. Check mic permissions.", "warn");
  }
}

async function initAmbientMode() {
  ambientEnabled = true;
  if (!ambientController) ambientController = new AmbientController();
  if (sessionId) ambientController.setSession(sessionId);
  await setAmbientEnabled(ambientEnabled);
}

// -------------------------
// Patient Summary + Coach
// -------------------------
async function loadSnapshot(force=false) {
  try {
    if (hasAiSummary && !force) return;
    const snap = buildPatientSummaryText(emrBackgroundText, transcriptBox.value || "");
    const h = hashLite(snap);
    if (!force && h === lastSnapshotHash) return;
    lastSnapshotHash = h;
    snapshotPanel.textContent = snap;
    refreshPatientAnchorFromSnapshotPreferred();
    markUpdated("snapshot");
  } catch (err) {
    snapshotPanel.textContent = "";
    panelUpdatedAt.snapshot = 0;
    uiError("Patient Summary", err);
  }
}
async function loadCoach(force=false) {
  const transcript = (transcriptBox.value || "").trim();
  if (transcript.length <= 20) {
    coachPanel.textContent = "";
    panelUpdatedAt.coach = 0;
    return;
  }
  try {
    await ensureSession();
    const data = await apiPost(`/session/${sessionId}/differential`);
    const diffText = (typeof data?.differential === "string") ? data.differential : safeJsonStringify(data);
    const h = hashLite(diffText);
    if (!force && h === lastCoachHash) {
      lastCoachRunAt = Date.now();
      return;
    }
    lastCoachHash = h;
    renderCoachOutput(diffText);
    lastCoachRunAt = Date.now();
    markUpdated("coach");
  } catch (err) {
    coachPanel.textContent = "";
    panelUpdatedAt.coach = 0;
    uiError("Clinical Coach", err);
  }
}
function countWords(text) {
  const t = (text || "").trim();
  if (!t) return 0;
  return t.split(/\s+/).filter(Boolean).length;
}

function isGarbageDelta(text) {
  const t = (text || "").toLowerCase().trim();
  if (t.length < 20) return false;
  const patterns = [
    "i am a student",
    "i am an ai",
    "i am a large language model",
    "sottotitoli",
    "amara.org",
    "subtitles",
  ];
  if (!patterns.some(p => t.includes(p))) return false;
  const words = t.match(/[a-z']+/g) || [];
  if (words.length <= 6) return true;
  const unique = new Set(words).size;
  return (unique / words.length) < 0.45;
}

function registerTranscriptDelta(deltaText, opts = {}) {
  const chunk = (deltaText || "").trim();
  if (!chunk) return;
  if (ambientController?.paused) return;
  if (isGarbageDelta(chunk)) return;
  coachPendingChars += chunk.length;
  coachPendingWords += countWords(chunk);
  maybeTriggerCoach(Boolean(opts.utteranceEnded));
}

function maybeTriggerCoach(utteranceEnded = false) {
  if (ambientController?.paused) return;
  const now = Date.now();
  if (now - lastCoachRunAt < COACH_DEBOUNCE_MS) return;
  const meetsChars = coachPendingChars >= COACH_MIN_DELTA_CHARS ||
    (utteranceEnded && coachPendingChars >= COACH_SMALL_DELTA_CHARS);
  const meetsWords = coachPendingWords >= COACH_MIN_DELTA_WORDS;
  if (!meetsChars || !meetsWords) return;
  coachPendingChars = 0;
  coachPendingWords = 0;
  lastCoachRunAt = now;
  loadCoach(false);
}

function renderCoachOutput(rawText) {
  const t = (rawText || "").trim();
  if (!t) {
    coachPanel.textContent = "";
    return;
  }

  let parsed = null;
  if (typeof t === "string") {
    const cleaned = stripCodeFences(t).trim();
    if (cleaned.startsWith("{") || cleaned.startsWith("[")) {
      try { parsed = JSON.parse(cleaned); } catch {}
    }
  } else if (typeof rawText === "object") {
    parsed = rawText;
  }

  if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
    coachPanel.textContent = t;
    return;
  }

  const listHtml = (items) => {
    if (!Array.isArray(items) || !items.length) return "";
    const li = items
      .map(i => String(i || "").trim())
      .filter(Boolean)
      .map(i => `<li>${escapeHtml(i)}</li>`)
      .join("");
    return li ? `<ul class="coach-list">${li}</ul>` : "";
  };

  const sections = [];
  const addSection = (title, items, extraClass="") => {
    const list = listHtml(items);
    if (!list) return;
    sections.push(`
      <div class="coach-section ${extraClass}">
        <div class="coach-title">${escapeHtml(title)}</div>
        ${list}
      </div>
    `.trim());
  };

  addSection("Differential", parsed.ddx);
  addSection("Key questions to refine DDx", parsed.key_questions_to_refine_ddx);
  addSection("Safety / Red flag / Can't miss", parsed.cant_miss_questions, "coach-cant-miss");
  addSection("Suggested Plan", parsed.suggested_plan);

  if (!sections.length) {
    coachPanel.textContent = t;
    return;
  }
  coachPanel.innerHTML = sections.join("");
}

// -------------------------
// EMR/background paste handling (no backend answer)
// -------------------------
async function handleEmrBackgroundPasteOnly(emrText) {
  await ensureSession();
  const clean = (emrText || "").trim();
  if (clean) {
    if (!emrBackgroundText.includes(clean)) {
      emrBackgroundText = (emrBackgroundText ? (emrBackgroundText + "\n\n") : "") + clean;
    }
  }

  setPatientAnchorFromTextBestEffort(emrBackgroundText);

  hasAiSummary = false;
  lastSnapshotHash = "";
  lastPatientSummaryHash = "";
  renderRapidSummary(true);
  clearTimeout(snapshotDebounce);
  snapshotDebounce = setTimeout(() => loadPatientSummaryAI(false), 400);

  const sid = sessionId;
  try {
    await apiPost(`/session/${sid}/clinical_background`, { background_text: emrBackgroundText });
  } catch (err) {
    // fallback (best-effort storage) without generating an answer
    try { await apiPost(`/session/${sid}/clinical_query`, { query: emrBackgroundText, mode: "background" }); } catch {}
  }
}

// -------------------------
// Clinical Query
// -------------------------
function readableFromMaybeJson(content) {
  const formatObjectLines = (obj, indent=0) => {
    if (!obj || typeof obj !== "object") return [];
    const pad = "  ".repeat(indent);
    const lines = [];
    for (const [key, val] of Object.entries(obj)) {
      if (val === null || val === undefined || val === "") continue;
      if (Array.isArray(val) && val.length === 0) continue;
      if (typeof val === "object" && !Array.isArray(val)) {
        lines.push(`${pad}${key}:`);
        const sub = formatObjectLines(val, indent + 1);
        if (sub.length) lines.push(...sub);
      } else if (Array.isArray(val)) {
        lines.push(`${pad}${key}:`);
        const sub = formatListLines(val, indent + 1);
        if (sub.length) lines.push(...sub);
      } else {
        lines.push(`${pad}${key}: ${String(val)}`);
      }
    }
    return lines;
  };
  const formatListLines = (arr, indent=0) => {
    if (!Array.isArray(arr)) return [];
    const pad = "  ".repeat(indent);
    const lines = [];
    for (const item of arr) {
      if (item === null || item === undefined || item === "") continue;
      if (typeof item === "object" && !Array.isArray(item)) {
        const sub = formatObjectLines(item, indent + 1);
        if (sub.length) {
          lines.push(`${pad}-`);
          lines.push(...sub.map(l => `${pad}  ${l}`));
        }
      } else if (Array.isArray(item)) {
        const sub = formatListLines(item, indent + 1);
        if (sub.length) {
          lines.push(`${pad}-`);
          lines.push(...sub.map(l => `${pad}  ${l}`));
        }
      } else {
        lines.push(`${pad}- ${String(item)}`);
      }
    }
    return lines;
  };
  const formatDirectAnswer = (val) => {
    if (typeof val === "string") return val.trim();
    if (Array.isArray(val)) return formatListLines(val, 0).join("\n").trim();
    if (val && typeof val === "object") return formatObjectLines(val, 0).join("\n").trim();
    return "";
  };
  const formatSection = (label, val) => {
    let lines = [];
    if (Array.isArray(val)) lines = formatListLines(val, 0);
    else if (val && typeof val === "object") lines = formatObjectLines(val, 0);
    else if (val !== null && val !== undefined && String(val).trim()) lines = [String(val).trim()];
    if (!lines.length) return "";
    const withBullets = lines.map(l => (l.trim().startsWith("-") ? l : `- ${l}`));
    return `${label}:\n${withBullets.join("\n")}`.trim();
  };

  let parsed = null;
  if (content && typeof content === "object") {
    parsed = content;
  } else if (typeof content === "string") {
    const t = stripCodeFences(content).trim();
    if (t.startsWith("{") || t.startsWith("[")) { try { parsed = JSON.parse(t); } catch {} }
    if (!parsed && t) {
      const i0 = t.indexOf("{");
      const i1 = t.lastIndexOf("}");
      if (i0 >= 0 && i1 > i0) {
        const sub = t.slice(i0, i1 + 1);
        try { parsed = JSON.parse(sub); } catch {}
      }
    }
    if (!parsed && t) {
      const j0 = t.indexOf("[");
      const j1 = t.lastIndexOf("]");
      if (j0 >= 0 && j1 > j0) {
        const sub = t.slice(j0, j1 + 1);
        try { parsed = JSON.parse(sub); } catch {}
      }
    }
  }
  if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
    const da = formatDirectAnswer(parsed.direct_answer);
    const parts = [];
    if (da) parts.push(da);
    const sections = [
      ["Recommended regimens", parsed.recommended_regimens],
      ["Interactions / contraindications", parsed.interactions_and_contraindications],
      ["Tests / workup", parsed.tests_or_workup],
      ["Red flags", parsed.red_flags],
      ["Missing critical info", parsed.missing_critical_info],
      ["Uncertainties", parsed.uncertainties],
      ["Follow up", parsed.follow_up],
    ];
    for (const [label, val] of sections) {
      const block = formatSection(label, val);
      if (block) parts.push(block);
    }
    if (parts.length) return parts.join("\n\n").trim();
  }
  return (typeof content === "string") ? content : safeJsonStringify(content);
}

function createDirectAnswerStreamParser() {
  const keyRe = /"direct_answer"\s*:\s*/;
  let buffer = "";
  let capturing = false;
  let mode = "";
  let done = false;
  let value = "";
  let escape = false;
  let inString = false;
  let arrayDepth = 0;
  let items = [];
  let current = "";

  return {
    push(chunk) {
      if (done) return value;
      buffer += String(chunk || "");

      if (!capturing) {
        const m = buffer.match(keyRe);
        if (!m) {
          if (buffer.length > 4000) buffer = buffer.slice(-4000);
          return value;
        }
        const start = (m.index || 0) + m[0].length;
        buffer = buffer.slice(start);
        capturing = true;
      }

      if (!mode) {
        const m = buffer.match(/^\s*([\[\"])/);
        if (!m) return value;
        mode = (m[1] === "[") ? "array" : "string";
        buffer = buffer.replace(/^\s*/, "");
      }

      let i = 0;
      while (i < buffer.length) {
        const ch = buffer[i];
        if (mode === "string") {
          if (ch === "\"" && !escape) {
            done = true;
            buffer = buffer.slice(i + 1);
            return value;
          }
          if (escape) {
            if (ch === "n") value += "\n";
            else if (ch === "t") value += "\t";
            else if (ch === "r") value += "\r";
            else value += ch;
            escape = false;
            i += 1;
            continue;
          }
          if (ch === "\\") {
            escape = true;
            i += 1;
            continue;
          }
          value += ch;
          i += 1;
          continue;
        }

        // array mode
        if (arrayDepth === 0) {
          if (ch === "[") {
            arrayDepth = 1;
            i += 1;
            continue;
          }
        }

        if (inString) {
          if (escape) {
            if (ch === "n") current += "\n";
            else if (ch === "t") current += "\t";
            else if (ch === "r") current += "\r";
            else current += ch;
            escape = false;
            i += 1;
            continue;
          }
          if (ch === "\\") {
            escape = true;
            i += 1;
            continue;
          }
          if (ch === "\"") {
            inString = false;
            if (current.trim()) items.push(current);
            current = "";
            i += 1;
            continue;
          }
          current += ch;
          i += 1;
          continue;
        }

        if (ch === "\"") {
          inString = true;
          i += 1;
          continue;
        }
        if (ch === "[") {
          arrayDepth += 1;
          i += 1;
          continue;
        }
        if (ch === "]") {
          arrayDepth -= 1;
          i += 1;
          if (arrayDepth <= 0) {
            done = true;
            buffer = buffer.slice(i);
            return value;
          }
          continue;
        }
        i += 1;
      }
      buffer = "";
      if (mode === "array") {
        const all = items.concat(current ? [current] : []).slice(0, 20);
        if (all.length) value = `- ${all.join("\n- ")}`.trim();
      }
      return value;
    },
    get value() { return value; },
    get done() { return done; },
  };
}

async function sendClinicalQueryWithDraft(queryText, macroOverride="", modelOverride="") {
  await ensureSession();
  const q = (queryText || "").trim();
  const mode = "fast";
  const overrideText = String(macroOverride || "").trim();
  const selectedMacro = overrideText ? null : getSelectedMacro();
  const macroText = overrideText || (selectedMacro?.content || "").trim();
  if (!q && !macroText) return;

  // If EMR/background paste: display only and do not generate an answer
  if (looksLikeEmrPaste(q)) {
    await handleEmrBackgroundPasteOnly(q);
    logChat("You", "[EMR/Background pasted]");
    return;
  }

  const logText = q || "";
  if (logText) {
    logChat("You", logText);
  }

  const payload = { query: q, mode };
  if (macroText) payload.macro = macroText;
  const model = modelOverride || (macroText ? "gpt-5-nano" : "");
  if (model) payload.model = model;

  const contentEl = addMessage("Centaur", "â€¦");
  scrollChatToMessageStart(contentEl);
  let streamedText = "";
  let meta = null;
  const parser = createDirectAnswerStreamParser();

  try {
    meta = await apiPostStreamNDJSON(
      `/session/${sessionId}/clinical_query_stream`,
      payload,
      (chunk) => {
        streamedText += chunk;
        const preview = parser.push(chunk);
        if (preview) {
          contentEl.textContent = stripPairedMarkdownEmphasis(preview);
        }
        if (chatAutoScroll) chatLog.scrollTop = chatLog.scrollHeight;
      }
    );
  } catch (err) {
    // Fallback to non-streaming if needed
    const data = await apiPost(`/session/${sessionId}/clinical_query`, payload);
    const rawContent = (data?.response !== undefined) ? data.response : data;
    const readable = readableFromMaybeJson(rawContent);
    const clean = stripPairedMarkdownEmphasis(readable);
    contentEl.innerHTML = safeSubsetFormat(clean);
    lastAssistantPlainText = clean;

    if (data?.promoted_to_background) {
      if (q && !emrBackgroundText.includes(q)) {
        emrBackgroundText = (emrBackgroundText ? (emrBackgroundText + "\n\n") : "") + q;
      }
      clearTimeout(snapshotDebounce);
      snapshotDebounce = setTimeout(() => loadSnapshot(false), 400);
      setPatientAnchorFromTextBestEffort(readable);
      hasAiSummary = false;
      loadPatientSummaryAI(false);
    }
    return;
  }

  const readable = readableFromMaybeJson(streamedText);
  const clean = stripPairedMarkdownEmphasis(readable);
  contentEl.innerHTML = safeSubsetFormat(clean);
  lastAssistantPlainText = clean;
  if (isNearBottom(chatLog)) chatLog.scrollTop = chatLog.scrollHeight;

  if (meta && meta.promoted_to_background) {
    if (q && !emrBackgroundText.includes(q)) {
      emrBackgroundText = (emrBackgroundText ? (emrBackgroundText + "\n\n") : "") + q;
    }
    clearTimeout(snapshotDebounce);
    snapshotDebounce = setTimeout(() => loadSnapshot(false), 400);
    setPatientAnchorFromTextBestEffort(readable);
    hasAiSummary = false;
    loadPatientSummaryAI(false);
  }
}

async function generateSoapToChat() {
  try {
    await ensureSession();
    logChat("System", "Generating SOAPâ€¦");
    const data = await apiPost(`/session/${sessionId}/make_soap`);
    const soapTextRaw = data?.soap || data?.soap_text || "No SOAP returned";
    const soapText = stripPairedMarkdownEmphasis(soapTextRaw);
    logChat("SOAP", soapText);
  } catch (err) {
    uiError("SOAP", err);
  }
}

async function generateReferralToChat() {
  try {
    await ensureSession();
    const extra = (chatInput.value || "").trim();
    chatInput.value = "";
    const transcript = (transcriptBox.value || "").trim();
    const bg = (emrBackgroundText || "").trim();

    if (!transcript && !bg) {
      logChat("System", "No transcript/background detected yet. Record audio or paste EMR/background, then click Referral again.");
      return;
    }

    logChat("System", "Generating referral letterâ€¦");
    const macro = getMacroByName("Referral");
    let instruction = "";
    if (macro?.content) {
      instruction = expandMacroTemplate(macro.content, {
        EMR: bg || "[none]",
        TRANSCRIPT: transcript || "[none]",
        EXTRA: extra || "[none]",
      });
    } else {
      instruction =
`Write a referral letter in Canadian/Alberta style.
Mandatory formatting:
- Start the letter body with: "Dear Colleague,"
- Use clear headings and short paragraphs.
- End the letter with exactly:
  Sincerely,
  (and DO NOT include any clinician name or credentials after Sincerely.)
Content requirements:
- Include: reason for referral, focused HPI, pertinent PMHx, meds/allergies if available, relevant exam/labs/imaging, what has been tried, specific question(s) for the consultant, urgency, and follow-up plan.
- If key details are missing, leave placeholders like [Consultant Name], [Clinic], [Fax], [Patient Name], [DOB], [PHN].
Extra instructions (if any):
${extra || "[none]"}
Background/EMR (if any):
${bg || "[none]"}
Live transcript:
${transcript || "[none]"}`;
    }

    const data = await apiPost(`/session/${sessionId}/clinical_query`, { query: "", mode: "fast", macro: instruction, model: "gpt-5-nano" });
    let content = data?.response ?? "";
    let letter = "";
    try {
      const parsed = (typeof content === "string") ? JSON.parse(stripCodeFences(content)) : content;
      if (parsed && typeof parsed === "object" && parsed.direct_answer) letter = String(parsed.direct_answer || "").trim();
    } catch {}
    if (!letter) letter = String(content || "").trim();
    const cleanLetter = stripPairedMarkdownEmphasis(letter);
    logChat("Referral", cleanLetter);
    setPatientAnchorFromTextBestEffort(cleanLetter);
  } catch (err) {
    uiError("Referral", err);
  }
}

// -------------------------
// BILLING (SIMPLIFIED)
// -------------------------
const DAILY_BILLING_TEXT_LS_PREFIX = "centaur_daily_billing_text_v1:";
const BILLING_MODEL_KEY_PREFIX = "centaur_billing_model_v1:";
let billingAutosaveTimer = null;

function todayStrLocal() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${day}`;
}
function billingUserKey(){ return String(authUser?.username || "anon"); }
function billingTextKeyToday(){ return `${DAILY_BILLING_TEXT_LS_PREFIX}${billingUserKey()}:${todayStrLocal()}`; }
function billingModelKey(){ return `${BILLING_MODEL_KEY_PREFIX}${billingUserKey()}`; }

function normalizeBillingModel(val){
  return (String(val || "").toUpperCase() === "PCPCM") ? "PCPCM" : "FFS";
}
function syncBillingDate(){
  if (billingDateEl) billingDateEl.textContent = todayStrLocal();
}
function getBillingModelPref(){
  return normalizeBillingModel(localStorage.getItem(billingModelKey()) || "FFS");
}
function setBillingModelPref(val){
  const norm = normalizeBillingModel(val);
  localStorage.setItem(billingModelKey(), norm);
  if (billingModelSelect) billingModelSelect.value = norm;
  return norm;
}
function getSelectedBillingModel(){
  if (billingModelSelect) return normalizeBillingModel(billingModelSelect.value);
  return getBillingModelPref();
}


function countPatientsFromText(t) {
  const lines = (t || "").split("\n").map(s => s.trim()).filter(Boolean);
  let c = 0;
  for (const ln of lines) {
    const lower = ln.toLowerCase();
    if (lower.startsWith("icd-9:")) continue;
    if (lower.startsWith("billing:")) continue;
    if (ln.includes(" | ")) c++;
  }
  return c;
}

function scrollBillingToEnd() {
  dailyBillingText.scrollTop = dailyBillingText.scrollHeight;
}

async function loadBillingFromLocal() {
  const key = billingTextKeyToday();
  const saved = localStorage.getItem(key);
  if (saved != null) dailyBillingText.value = saved;
  setBillingModelPref(getBillingModelPref());
  syncBillingDate();
  scrollBillingToEnd();
}

async function loadBillingFromServer() {
  try {
    const data = await apiGet(`/billing/today`);
    const serverText = String(data?.billing_text || "");
    const localText = String(localStorage.getItem(billingTextKeyToday()) || "");
    if (!serverText.trim() && localText.trim()) {
      dailyBillingText.value = localText;
      try { await saveBillingToServer(); } catch {}
    } else {
      dailyBillingText.value = serverText;
      try { localStorage.setItem(billingTextKeyToday(), serverText); } catch {}
    }
    const serverModel = normalizeBillingModel(data?.billing_model || "");
    setBillingModelPref(serverModel);
    syncBillingDate();
    scrollBillingToEnd();
  } catch {
    setBillingModelPref(getBillingModelPref());
    await loadBillingFromLocal();
  }
}

async function saveBillingToLocal() {
  localStorage.setItem(billingTextKeyToday(), dailyBillingText.value || "");
}

async function saveBillingToServer() {
  const billing_text = dailyBillingText.value || "";
  await apiPost(`/billing/save`, { billing_text, billing_model: getSelectedBillingModel() });
}

function scheduleBillingAutosave() {
  clearTimeout(billingAutosaveTimer);
  billingAutosaveTimer = setTimeout(async () => {
    try { await saveBillingToServer(); } catch {}
  }, 900);
}

async function billNow() {
  await ensureSession();

  const data = await apiPost(`/session/${sessionId}/billing/bill`, { billing_model: getSelectedBillingModel() });

  const billingText = String(data?.billing_text || "").trim();
  if (!billingText) {
    logChat("System", "Billing generator returned empty entry.");
    return;
  }

  dailyBillingText.value = billingText + "\n";
  hasBilledCurrentPatient = true;

  await saveBillingToLocal();
  scrollBillingToEnd();

  try { await saveBillingToServer(); } catch {}
}

async function saveBillingEdits() {
  await saveBillingToLocal();
  await saveBillingToServer();
}

async function printBillingList() {
  const resp = await apiPost(`/billing/print`);
  const printable = String(resp?.print_text || "").trim();
  const metaDate = String(resp?.date || todayStrLocal());
  const metaCount = String(resp?.total_patient_count ?? countPatientsFromText(dailyBillingText.value || ""));
  const physicianName = await getPhysicianPrintName();
  openBillingPrintWindow(printable, metaDate, metaCount, physicianName);

  setTimeout(() => {
    try { localStorage.removeItem(billingTextKeyToday()); } catch {}
    dailyBillingText.value = "";
  }, 250);
}

// -------------------------
// UI wiring
// -------------------------
authTabLogin?.addEventListener("click", () => setAuthMode("login"));
authTabSignup?.addEventListener("click", () => setAuthMode("signup"));
authLoginForm?.addEventListener("submit", async (e) => {
  e.preventDefault();
  const username = (authLoginUsername?.value || "").trim();
  const password = authLoginPassword?.value || "";
  if (!username || !password) {
    showAuthError("Enter username and password.");
    return;
  }
  try {
    const data = await apiPost("/auth/login", { username, password });
    setAuthToken(data?.token || "");
    authUser = data?.user || null;
    if (authLoginPassword) authLoginPassword.value = "";
    setAdminUIVisibility();
    hideAuthOverlay();
    await bootstrapApp();
  } catch (err) {
    showAuthError(err?.message || "Login failed.");
  }
});
authSignupForm?.addEventListener("submit", async (e) => {
  e.preventDefault();
  const username = (authSignupUsername?.value || "").trim();
  const email = (authSignupEmail?.value || "").trim();
  const password = authSignupPassword?.value || "";
  if (!username || !email || !password) {
    showAuthError("Enter username, email, and password.");
    return;
  }
  try {
    const data = await apiPost("/auth/signup", { username, email, password });
    setAuthToken(data?.token || "");
    authUser = data?.user || null;
    if (authSignupPassword) authSignupPassword.value = "";
    setAdminUIVisibility();
    hideAuthOverlay();
    await bootstrapApp();
  } catch (err) {
    showAuthError(err?.message || "Sign up failed.");
  }
});

menuBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  toggleMenuPopover();
});
menuPopover?.addEventListener("click", (e) => e.stopPropagation());
profileBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  toggleProfilePopover();
});
profilePopover?.addEventListener("click", (e) => e.stopPropagation());
localKbBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (!authUser?.is_admin) {
    showToast("Admin access required.", "error");
    return;
  }
  profilePopover.style.display = "none";
  openKbPanel();
});
themeBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  toggleTheme();
});
globalCopyBtn?.addEventListener("click", async (e) => {
  e.preventDefault();
  e.stopPropagation();
  flashButton(globalCopyBtn);
  await copyFullContextToClipboard();
});
macroBuilderBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  closeMenuPopover();
  openMacroPanel();
});
aboutBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  closeMenuPopover();
  openAboutPanel();
});
feedbackBtn?.addEventListener("click", (e) => {
  e.preventDefault();
  closeMenuPopover();
  openFeedbackPanel();
});
macroCloseBtn?.addEventListener("click", () => closeMacroPanel());
macroOverlay?.addEventListener("click", () => closeMacroPanel());
aboutCloseBtn?.addEventListener("click", () => closeAboutPanel());
aboutOverlay?.addEventListener("click", () => closeAboutPanel());
feedbackCloseBtn?.addEventListener("click", () => closeFeedbackPanel());
feedbackOverlay?.addEventListener("click", () => closeFeedbackPanel());
feedbackPanel?.addEventListener("click", (e) => e.stopPropagation());
feedbackCancelBtn?.addEventListener("click", () => closeFeedbackPanel());
feedbackSendBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(feedbackSendBtn, "Sendingâ€¦", sendFeedback);
});
let recordToggleBusy = false;
recordBtn?.addEventListener("click", async () => {
  if (recordToggleBusy) return;
  recordToggleBusy = true;
  try {
    if (isRecording) {
      stopRecording();
    } else {
      await startRecording();
    }
  } finally {
    recordToggleBusy = false;
  }
});
profileCloseBtn?.addEventListener("click", () => closeProfilePanel());
profileOverlay?.addEventListener("click", () => closeProfilePanel());
profilePanel?.addEventListener("click", (e) => e.stopPropagation());
profileCancelBtn?.addEventListener("click", () => closeProfilePanel());
kbCloseBtn?.addEventListener("click", () => closeKbPanel());
kbOverlay?.addEventListener("click", () => closeKbPanel());
kbPanel?.addEventListener("click", (e) => e.stopPropagation());
kbIndexBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(kbIndexBtn, "Indexingâ€¦", indexKbSite);
});
kbRefreshBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(kbRefreshBtn, "Refreshingâ€¦", loadKbSites);
});
kbSitesTab?.addEventListener("click", () => setKbTab("sites"));
kbGuidelinesTab?.addEventListener("click", () => setKbTab("guidelines"));
kbGuidelineRefreshBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(kbGuidelineRefreshBtn, "Refreshingâ€¦", loadKbGuidelines);
});
kbGuidelineCloseBtn?.addEventListener("click", () => closeKbGuidelinePanel());
kbGuidelineCloseBtn2?.addEventListener("click", () => closeKbGuidelinePanel());
kbGuidelineOverlay?.addEventListener("click", () => closeKbGuidelinePanel());
kbGuidelinePanel?.addEventListener("click", (e) => e.stopPropagation());
kbGuidelineAddNode?.addEventListener("click", () => addGuidelineNodeRow());
kbGuidelineAddEdge?.addEventListener("click", () => addGuidelineEdgeRow());
kbGuidelineSaveBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(kbGuidelineSaveBtn, "Savingâ€¦", saveGuidelinePatch);
});
kbGuidelineReextractBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(kbGuidelineReextractBtn, "Re-extractingâ€¦", reextractGuideline);
});
profileSaveBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(profileSaveBtn, "Savingâ€¦", saveProfile);
});
referralCloseBtn?.addEventListener("click", () => closeReferralPanel());
referralCloseBtn2?.addEventListener("click", () => closeReferralPanel());
referralOverlay?.addEventListener("click", () => closeReferralPanel());
referralPanel?.addEventListener("click", (e) => e.stopPropagation());
referralCopyBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(referralCopyBtn, "Copyingâ€¦", copyReferralDraft);
});
noteDraftCopyBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(noteDraftCopyBtn, "Copyingâ€¦", async () => {
    const text = (noteDraftText?.value || "").trim();
    if (!text) {
      setNoteDraftStatus("Nothing to copy yet.", true);
      return;
    }
    const ok = await copyRichText(text);
    if (ok) {
      showToast("Copied.", "ok");
      setNoteDraftStatus("");
      return;
    }
    setNoteDraftStatus("Copy blocked. Use manual copy.", true);
  });
});
referralGenerateBtn?.addEventListener("click", async () => {
  const override = (referralSpecialtyInput?.value || "").trim();
  await runWithButtonBusy(referralGenerateBtn, "Generatingâ€¦", () => generateReferralDraft(override));
});
referralSpecialtyInput?.addEventListener("keydown", (e) => {
  if (e.key !== "Enter") return;
  e.preventDefault();
  referralGenerateBtn?.click();
});
noteDraftCloseBtn?.addEventListener("click", () => closeNoteDraftPanel());
noteDraftCloseBtn2?.addEventListener("click", () => closeNoteDraftPanel());
noteDraftOverlay?.addEventListener("click", () => closeNoteDraftPanel());
noteDraftPanel?.addEventListener("click", (e) => e.stopPropagation());
feedbackEmail?.addEventListener("change", () => {
  maybeStoreFeedbackEmail(feedbackEmail.value || "");
});
billingArchiveCloseBtn?.addEventListener("click", () => closeBillingArchivePanel());
billingArchiveOverlay?.addEventListener("click", () => closeBillingArchivePanel());
billingArchivePanel?.addEventListener("click", (e) => e.stopPropagation());
macroAddBtn?.addEventListener("click", () => startNewMacro());
macroSaveBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(macroSaveBtn, "Savingâ€¦", saveMacroFromEditor);
});
macroCancelBtn?.addEventListener("click", () => cancelMacroEdit());
macroEditBtn?.addEventListener("click", () => editMacroFromPicker());
macroDeleteBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(macroDeleteBtn, "Deletingâ€¦", deleteMacroFromPicker);
});
newPatientConfirmCancelBtn?.addEventListener("click", () => closeNewPatientConfirm());
newPatientConfirmProceedBtn?.addEventListener("click", async () => {
  closeNewPatientConfirm();
  await maybeCreateNoteLogSnapshot();
  await startNewPatientSession();
});
newPatientConfirmOverlay?.addEventListener("click", () => closeNewPatientConfirm());
signOutBtn?.addEventListener("click", async () => {
  closeProfilePopover();
  try { stopRecording(true); } catch {}
  try { await ambientController?.disable(); } catch {}
  try { await apiPost("/auth/logout"); } catch {}
  clearAuthToken();
  window.location.reload();
});
reviewBillingBtn?.addEventListener("click", async () => {
  closeProfilePopover();
  openBillingArchivePanel();
  await loadBillingArchives();
});
personalizationBtn?.addEventListener("click", () => {
  closeProfilePopover();
  openProfilePanel();
});
coachReportBtn?.addEventListener("click", () => {
  closeProfilePopover();
  logChat("System", "Coach Report is coming soon.");
});
billingArchiveRefreshBtn?.addEventListener("click", async () => {
  await loadBillingArchives();
});
billingArchiveDeleteBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(billingArchiveDeleteBtn, "Deletingâ€¦", deleteBillingArchive);
});
billingArchiveSelect?.addEventListener("change", async () => {
  const name = billingArchiveSelect.value;
  if (!name) return;
  await loadBillingArchive(name);
});
billingArchiveSaveBtn?.addEventListener("click", async () => {
  await runWithButtonFeedback(billingArchiveSaveBtn, "Savingâ€¦", "Saved", saveBillingArchive);
});
billingArchivePrintBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(billingArchivePrintBtn, "Printingâ€¦", reprintBillingArchive);
});
noteLogBtn?.addEventListener("click", openNoteLogPanel);
noteLogCloseBtn?.addEventListener("click", closeNoteLogPanel);
noteLogCloseBtn2?.addEventListener("click", closeNoteLogPanel);
noteLogOverlay?.addEventListener("click", closeNoteLogPanel);
noteLogPanel?.addEventListener("click", (e) => e.stopPropagation());
noteLogTabOutputs?.addEventListener("click", () => setNoteLogTab("outputs"));
noteLogTabInputs?.addEventListener("click", () => setNoteLogTab("inputs"));
noteLogTabMeta?.addEventListener("click", () => setNoteLogTab("meta"));
noteLogSearch?.addEventListener("input", () => {
  renderNoteLogList(filterNoteLogItems(noteLogSearch?.value || ""));
});
noteLogDeleteBtn?.addEventListener("click", () => deleteNoteLogEntry());
macroSelect?.addEventListener("change", async () => {
  const id = macroSelect.value;
  const macro = macros.find(m => m.id === id);
  setSelectedMacroId("");
  if (macroSelect) macroSelect.value = "";
  if (macro?.content) {
    const expanded = expandMacroTemplate(macro.content, {
      EMR: emrBackgroundText || "[none]",
      TRANSCRIPT: transcriptBox.value || "[none]",
      EXTRA: "",
    });
    const label = macro?.name || "Template";
    await openNoteDraftPanel({
      templateId: id,
      templateLabel: label,
      generate: () => generateTemplateDraft(expanded, "gpt-5-nano"),
    });
  }
});
macroPickerSelect?.addEventListener("change", () => {
  const selected = macros.find(m => m.id === macroPickerSelect.value);
  if (macroDeleteBtn) {
    const locked = Boolean(selected?.locked);
    macroDeleteBtn.disabled = locked;
    macroDeleteBtn.textContent = locked ? "Locked" : "Delete";
  }
});
waveformBtn?.addEventListener("click", async () => {
  if (!ambientController) return;
  if (!ambientController.enabled || ambientController.error) {
    await setAmbientEnabled(true);
    return;
  }
  if (ambientController.paused) {
    await ambientController.resume();
    return;
  }
  ambientController.pause();
});

snapshotPanel.addEventListener("dblclick", () => loadPatientSummaryAI(true));
coachPanel.addEventListener("dblclick", () => loadCoach(true));

newBtn.addEventListener("click", async () => {
  if (hasCurrentPatientData() && !hasBilledCurrentPatient) {
    openNewPatientConfirm();
    return;
  }
  await maybeCreateNoteLogSnapshot();
  await startNewPatientSession();
});

sendBtn.addEventListener("click", async () => {
  const q = chatInput.value;
  chatInput.value = "";
  flashButton(sendBtn);
  await sendClinicalQueryWithDraft(q);
});

// EMR paste: show only, do not generate any answer
chatInput.addEventListener("paste", async (e) => {
  try {
    const pasted = (e.clipboardData || window.clipboardData)?.getData("text") || "";
    if (!looksLikeEmrPaste(pasted)) return;

    e.preventDefault();
    chatInput.value = "";

    await handleEmrBackgroundPasteOnly(pasted);
    logChat("You", "[EMR/Background pasted]");
  } catch {}
});

chatInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendBtn.click();
  }
});

document.addEventListener("click", () => { closeMenuPopover(); closeProfilePopover(); });
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeMenuPopover();
    closeMacroPanel();
    closeProfilePopover();
    closeBillingArchivePanel();
    closeReferralPanel();
    closeNoteDraftPanel();
    closeProfilePanel();
  }
});
window.addEventListener("online", () => ambientController?.updateStatus());
window.addEventListener("offline", () => ambientController?.updateStatus());

// Add Copy button left of SOAP
(function addCopyButtonLeft(){
  const actions = document.querySelector(".query-actions");
  if (!actions) return;
  const copyBtn = document.createElement("button");
  copyBtn.className = "primary";
  copyBtn.type = "button";
  copyBtn.textContent = "Copy";
  actions.insertBefore(copyBtn, soapBtn);
  copyBtn.addEventListener("click", async () => {
    await runWithButtonFeedback(copyBtn, "Copyingâ€¦", "Copied", async () => {
      const text = (lastAssistantPlainText || "").trim();
      if (!text) { logChat("System", "Nothing to copy yet. Generate SOAP or Referral first."); return; }
      await copyRichText(text);
      logChat("System", "Last output copied (rich formatting).");
    });
  });
})();

soapBtn.addEventListener("click", async () => {
  await runWithButtonBusy(soapBtn, "Workingâ€¦", async () => {
    await openNoteDraftPanel({
      templateId: "soap",
      templateLabel: "SOAP Note",
      generate: generateSoapDraft,
    });
  });
});
referralBtn.addEventListener("click", () => { openReferralPanel(); });
rxBtn?.addEventListener("click", async () => {
  await runWithButtonBusy(rxBtn, "Workingâ€¦", async () => {
    await openNoteDraftPanel({
      templateId: "rx",
      templateLabel: "Rx Recommendation",
      generate: generateRxDraft,
    });
  });
});

// -------------------------
// Billing wiring (SIMPLIFIED)
// -------------------------
dailyBillingText.addEventListener("input", () => {
  try { saveBillingToLocal(); } catch {}
  scheduleBillingAutosave();
});

billingModelSelect?.addEventListener("change", async () => {
  const model = setBillingModelPref(getSelectedBillingModel());
  try {
    await apiPost(`/billing/model`, { billing_model: model });
    logChat("System", `Billing model set to ${model}.`);
  } catch (err) {
    uiError("Billing model", err);
  }
});

billBtn.addEventListener("click", async () => {
  await runWithButtonBusy(billBtn, "Billingâ€¦", async () => {
    try { await billNow(); }
    catch (err) { uiError("Bill", err); }
  });
});

saveBillingBtn.addEventListener("click", async () => {
  await runWithButtonFeedback(saveBillingBtn, "Savingâ€¦", "Saved", async () => {
    try {
      await saveBillingEdits();
      logChat("System", "Billing list saved.");
    } catch (err) {
      uiError("Save billing", err);
    }
  });
});

printBillingBtn.addEventListener("click", async () => {
  await runWithButtonBusy(printBillingBtn, "Printingâ€¦", async () => {
    try { await printBillingList(); }
    catch (err) { uiError("Print billing", err); }
  });
});

// Best-effort cleanup
window.addEventListener("beforeunload", () => {
  try { stopRecording(true); } catch {}
  try { saveBillingToLocal(); } catch {}
});

// -------------------------
// Init
// -------------------------
(async function init() {
  try {
    setRecordingUI(false);
    initTheme();

    const authed = await ensureAuth();
    if (authed) {
      await bootstrapApp();
    }
  } catch (err) {
    uiError("Init", err);
  }
})();
</script>
</body>
</html>
